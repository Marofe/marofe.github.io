(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{11:function(e,a,t){},17:function(e,a,t){},32:function(e,a,t){e.exports=t(55)},37:function(e,a,t){},38:function(e,a,t){},46:function(e,a,t){},47:function(e,a,t){},49:function(e,a,t){},55:function(e,a,t){"use strict";t.r(a);var n=t(0),r=t.n(n),i=t(24),o=t.n(i),l=(t(37),t(38),function(e){return r.a.createElement("div",{className:"layout"},e.children)}),m=t(14),s=t(8),c=t(3),d=t.n(c),h=(t(46),function(){return r.a.createElement("div",{className:"divPage"},r.a.createElement(d.a,null,r.a.createElement("title",null,"Marcos Rog\xe9rio Fernandes | Personal Website"),r.a.createElement("meta",{name:"description",content:"Welcome to my personal website. Here you will find my reserach interest and contributions. "})),r.a.createElement("div",{className:"homepage_top"},r.a.createElement("img",{alt:"perfil",class:"homepage_myfoto",src:"https://avatars1.githubusercontent.com/u/4412144?s=460&v=4"}),r.a.createElement("h1",null,"Marcos Rog\xe9rio Fernandes"),r.a.createElement("p",null,"I'm a Control Engineer, programmer and a researcher. I work on ideas and tools related to Electrical Engineer, Automation and Computer Science. I'm a PhD Student at School of Electrical and Computer Engineering from Unicamp (FEEC/Unicamp).")),r.a.createElement("article",null,r.a.createElement("h2",null,"My Research Interest:"),r.a.createElement("ul",null,r.a.createElement("li",null,"Statistic Learning"),r.a.createElement("li",null,"Kalman Filtering"),r.a.createElement("li",null,"Navigation & Tracking Systems"),r.a.createElement("li",null,"Optimal and Robust Control Systems"),r.a.createElement("li",null,"Mobile Robotics"),r.a.createElement("li",null,"Computer Vision")),r.a.createElement("h2",null,"Contact-me"),r.a.createElement("div",{className:"social_media"},r.a.createElement("a",{href:"https://www.facebook.com/eng.marofe",class:"fa fa-facebook"}),r.a.createElement("a",{href:"https://twitter.com/_marofe",class:"fa fa-twitter"}),r.a.createElement("a",{href:"https://www.instagram.com/_marofe",class:"fa fa-instagram"}),r.a.createElement("a",{href:"https://www.linkedin.com/in/marcos-rogerio-fernandes/",class:"fa fa-linkedin"}),r.a.createElement("a",{href:"https://www.researchgate.net/profile/Marcos_Fernandes10",class:"fa fa-researchgate"}),r.a.createElement("a",{href:"https://github.com/Marofe",class:"fa fa-github"}),r.a.createElement("a",{href:"mailto:eng.marofe@hotmail.com",class:"fa fa-envelope"}))))}),u=(t(47),function(){return r.a.createElement("div",{className:"divPages pgPublication"},r.a.createElement(d.a,null,r.a.createElement("title",null,"Publications | Marcos Rog\xe9rio Fernandes"),r.a.createElement("meta",{name:"description",content:"Welcome to my personal website. Here you will find my main contributions. "})),r.a.createElement("div",{className:"top"},r.a.createElement("h1",null,"My Publications"),r.a.createElement("p",null,"Here is an overview of my latest works and publications.")),r.a.createElement("article",null,r.a.createElement("h2",null,"Journals:"),r.a.createElement("ul",null,r.a.createElement("li",null,r.a.createElement("p",null,'M. R. Fernandes, J. B. R. do Val and R. F. Souto, "Robust Estimation and Filtering for Poorly Known Models," in IEEE Control Systems Letters, vol. 4, no. 2, pp. 474-479, April 2020.',r.a.createElement("br",null),"[",r.a.createElement("a",{href:"https://ieeexplore.ieee.org/document/8891731"},"Download (IEEE Explorer)"),"]"))),r.a.createElement("h2",null,"Conference Papers:"),r.a.createElement("ul",null,r.a.createElement("li",null,r.a.createElement("p",null,"FERNANDES, MARCOS R.; DO VAL, JOAO B. R. ; SOUTO, RAFAEL F. . Filtering of Poorly Known Systems: Estimation Variations as Source of Uncertainty. In: 2018 IEEE Conference on Decision and Control (CDC), 2018, FL. 2018 IEEE Conference on Decision and Control (CDC), 2018. p. 3074.",r.a.createElement("br",null),"[",r.a.createElement("a",{href:"https://ieeexplore.ieee.org/document/8619306"},"Download (IEEE Explorer)"),"][",r.a.createElement("a",{href:"https://www.researchgate.net/publication/329895979_Slides"},"Slides"),"] [",r.a.createElement("a",{href:"https://github.com/Marofe/EVIU"},"Code"),"]")),r.a.createElement("li",null,r.a.createElement("p",null,"FERNANDES, M. R.; SOUTO, R. F. ; DO VAL, J. B. R. . FILTRAGEM DE SISTEMAS NA\u0303O-LINEARES: CONSIDERANDO A VARIAC\u0327A\u0303O DA ESTIMATIVA COMO FONTE DE INCERTEZA. In: Congresso Brasileiro de Autom\xe1tica, 2018, Jo\xe3o Pessoa. Anais do XXII Congresso Brasileiro de Autom\xe1tica, 2018.",r.a.createElement("br",null),"[",r.a.createElement("a",{href:"http://dx.doi.org/10.20906/CPS/CBA2018-1140"},"Download (Portuguese)"),"][",r.a.createElement("a",{href:"https://github.com/Marofe/EVIU"},"Code"),"]")),r.a.createElement("li",null,r.a.createElement("p",null,"DE OLIVEIRA, MARIO. O. F. ; FERNANDES, M. R. ; SOUTO, RAFAEL F. . Implementation of a Low-cost Prototype of Twin Rotor for academic studies in identification, optimal control and stochastic filtering. In: 2017 6th International Conference on Systems and Control (ICSC), 2017, Batna. 2017 6th International Conference on Systems and Control (ICSC), 2017. p. 193-198.",r.a.createElement("br",null),"[",r.a.createElement("a",{href:"https://ieeexplore.ieee.org/document/7958718"},"Download (IEEE Explorer)"),"]")),r.a.createElement("li",null,r.a.createElement("p",null,"FERNANDES, MARCOS. R.; DE OLIVEIRA, MARIO. O. F. ; SOUTO, R. F. . CONSTRU\xc7\xc3O DE UM PROT\xd3TIPO DE HELIC\xd3PTERO DE BAIXO CUSTO PARA ESTUDOS EM IDENTIFICA\xc7\xc3O DE SISTEMAS. In: Simp\xf3sio Brasileiro de Automa\xe7\xe3o Inteligente, 2017, Porto Alegre. Anais do XIII Simpo\u0301sio Brasileiro de Automac\u0327a\u0303o Inteligente, 2017. p. 1177-1183.",r.a.createElement("br",null),"[",r.a.createElement("a",{href:"https://www.ufrgs.br/sbai17/papers/paper_332.pdf"},"Download (Portuguese)"),"]"))),r.a.createElement("h2",null,"Master's Dissertation:"),r.a.createElement("p",null,"FERNANDES, M. R.; Stochastic Filtering: Estimation Variation as Source of Uncertainty. FEEC/UNICAMP, 2019.",r.a.createElement("br",null),"[",r.a.createElement("a",{href:"http://repositorio.unicamp.br/jspui/handle/REPOSIP/334481"},"Download (Portuguese)"),"] [",r.a.createElement("a",{href:"https://www.researchgate.net/publication/334710395_mestrado-slidespdf"},"Slides"),"] [",r.a.createElement("a",{href:"https://github.com/Marofe/EVIU"},"Code"),"]"),r.a.createElement("h2",null,"Undergraduate's Final Project:"),r.a.createElement("p",null,"FERNANDES, M. R.; DE OLIVEIRA, M. O. F. ; Study and Development of Optimal Control Systems and Stochastic Filtering. UTFPR, 2016.",r.a.createElement("br",null),"[",r.a.createElement("a",{href:"https://www.researchgate.net/publication/313426875_Estudo_e_Desenvolvimento_de_Sistemas_de_Controle_Otimo_com_Filtragem_Estocastica"},"Download (Portuguese)"),"]")))}),p=(t(11),t(1)),g=t(13),E=t.n(g),f=function(e){return r.a.createElement("span",{dangerouslySetInnerHTML:{__html:E.a.renderToString(e.math)}})},_=(t(12),t(49),function(e){return r.a.createElement("div",{className:"divImage"},r.a.createElement("img",{className:e.className,alt:e.alt,src:e.src,width:e.width,height:e.height}),r.a.createElement("br",null),r.a.createElement("span",null,e.legend))}),b=t(7),k=t.n(b),v=function(){return console.log("/tutorials/rastreamento_usando_visao_filtro_kalman"),r.a.createElement("article",null,r.a.createElement(d.a,null,r.a.createElement("title",null,"Rastreamento de Objetos usando Vis\xe3o Computacional e Filtro de Kalman | Marcos Rog\xe9rio Fernandes"),r.a.createElement("meta",{name:"description",content:"Welcome to my personal website. Here you will find my reserach interest and contributions. "})),r.a.createElement("h1",null,"Rastreamento de Objetos usando Vis\xe3o Computacional e Filtro de Kalman"),r.a.createElement(_,{src:"https://4.bp.blogspot.com/-J-tkGAP5-DA/WV7cvNDr5mI/AAAAAAAAAV4/hHQS3uj5H-gK040plU-Ikg6MSpQjtSmDwCLcBGAs/s400/Untitled.jpg",alt:"Computer Vision",legend:"Rastreamento de Objetos"}),r.a.createElement("p",null,"Este trabalho apresenta um algoritmo em tempo real para rastreamento de objetos em vis\xe3o computacional, usando o Filtro de Kalman como mecanismo de predi\xe7\xe3o para situa\xe7\xf5es de oclus\xe3o e ou contamina\xe7\xe3o da cena por ru\xeddo. O principal objetivo deste trabalho \xe9 de apresentar de forma did\xe1tica o desenvolvimento de um algoritmo de rastreamento de objetos baseado em cor. O algoritmo apresentado faz o rastreamento do maior objeto sim\xe9trico de uma cor pr\xe9-definida presente na cena. \xc9 apresentado em detalhes a implementa\xe7\xe3o da etapa de segmenta\xe7\xe3o da imagem, e posteriormente \xe9 apresentado uma estrat\xe9gia para tratar situa\xe7\xf5es com dois objetos da mesma cor. Por fim \xe9 demonstrado o uso do Filtro de Kalmam."),r.a.createElement("p",null,"\xdaltima atualiza\xe7\xe3o:  13 de Dezembro de 2015."),r.a.createElement("h3",null,"INTRODU\xc7\xc3O"),r.a.createElement("p",null,"O rastreamento de objetos \xe9 uma das mais importantes \xe1reas da vis\xe3o computacional, com extensas aplica\xe7\xf5es tanto para ind\xfastria pesada como automobilismo, assim como para a ind\xfastria do entretenimento, al\xe9m de ser uma poderosa ferramenta na \xe1rea m\xe9dica (Pinho et al., 2004). Vis\xe3o computacional consiste em t\xe9cnicas computacionais no qual possibilita interpretar imagens (WANGENHEIM et al., 2001). Segundo (Freitas et al.,2010), as principais aplica\xe7\xf5es do rastreamento de objetos em imagens s\xe3o para diagn\xf3sticos m\xe9dicos, interfaces Homem-Computador para controle de jogos eletr\xf4nicos e na \xe1rea de seguran\xe7a, para o monitoramento de ambientes com grandes fluxos de pessoas, tais como aeroportos, plataformas de trens e estacionamentos. O objetivo principal na \xe1rea de seguran\xe7a \xe9 detectar atrav\xe9s dos sistemas de rastreamento de objetos atividades indesejadas, contribuindo para a tomada de decis\xf5es dos profissionais de seguran\xe7a (Relli, 2014).Um algoritmo de rastreamento de objetos busca a partir de cenas provindas de um sensor \xf3ptico, como uma c\xe2mera, identificar a trajet\xf3ria que um ou mais objetos descrevem. No entanto, existem diversos fatores que dificultam a identifica\xe7\xe3o da trajet\xf3ria descrita por um objeto no mundo real. Seja por varia\xe7\xf5es de ilumina\xe7\xe3o, como o ascender ou apagar de luzes, ru\xeddos de fundo e principalmente oclus\xf5es que eventualmente o objeto sofra (Weng et al., 2006). Para contornar as dificuldades do mundo real para o rastreamento de objetos, \xe9 feito o uso de diversas estrat\xe9gias de predi\xe7\xe3o como o Filtro de Part\xedculas e o Filtro de Kalman (Iraei and Faez, 2015).Os sistemas de rastreamento de objetos usando vis\xe3o computacional podem ser divido em tr\xeas est\xe1gios, conforme ilustrado na Figura 1. O primeiro est\xe1gio \xe9 onde ocorre a segmenta\xe7\xe3o da imagem, o segundo est\xe1gio \xe9 onde faz-se o rastreamento ao longo do tempo do objeto ou alvo (",r.a.createElement("i",null,"target"),") e no ultimo est\xe1gio, faz-se a classifica\xe7\xe3o dos objetos quanto a suas a\xe7\xf5es executadas."),r.a.createElement(_,{src:"https://3.bp.blogspot.com/-Mad91z12UTo/WV7e5j1RkRI/AAAAAAAAAV8/1uTcrkXLTxodkvw2r_DDTnEBA3smrcfAQCLcBGAs/s320/sys_rast.png",alt:"Workflow",legend:"Figura 1 - Etapas"}),r.a.createElement("h3",null,"O Filtro de Kalman "),r.a.createElement("p",null,"O Filtro de Kalman consiste em um conjunto de equa\xe7\xf5es que possibilitam a implementa\xe7\xe3o recursiva de um estimador, gerando predi\xe7\xe3o \xf3tima dos estados futuros de um sistema linear a partir de uma observa\xe7\xe3o presente (Welch and Bishop, 1995). Foi desenvolvido em meados de 1960 por Rudolf Emil Kalman (Kalman et al., 1960), inicialmente para aplica\xe7\xf5es aeroespaciais. No entanto, logo vislumbraram-se diversas aplica\xe7\xf5es em outras \xe1reas, como rob\xf3tica m\xf3vel, rastreamento de alvos, identifica\xe7\xe3o de sistemas, controle de processos, an\xe1lise e processamento de sinais entre outros (Funk, 2003). Existem hoje varia\xe7\xf5es para sistemas n\xe3o-lineares, como o Filtro de Kalman Estendido (EKF) e o Filtro de Kalman Unscented (UKF). Neste trabalho ser\xe1 feito o uso do Filtro de Kalman linear (KF) que busca gerar estimativas \xf3timas dos estados de um sistema descrito por"),r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r x_{k+1}&=Ax_k+Bu_k+w_k\\\\\r y_k &= Cx_k + v_k\\end{aligned}"}),"No qual ",r.a.createElement(f,{math:"x_k \\in \\mathbb{R}^n"})," \xe9 o vetor de estados, ",r.a.createElement(f,{math:"A \\in \\mathbb{R}^{n\\times n}"})," \xe9 a matriz de estado, ",r.a.createElement(f,{math:"B \\in \\mathbb{R}^{n\\times m}"})," \xe9 a matriz de entrada, ",r.a.createElement(f,{math:"u_k \\in \\mathbb{R}^m"})," \xe9 o vetor de entrada, ",r.a.createElement(f,{math:"w_k"})," representa a incerteza associada a modelagem do processo, no qual \xe9 assumido como sendo uma distribui\xe7\xe3o gaussiana, com m\xe9dia nula, ",r.a.createElement(f,{math:"y_k \\in \\mathbb{R}^p"})," o vetor de sa\xedda, ",r.a.createElement(f,{math:"C \\in \\mathbb{R}^{p\\times n}"})," a matriz de sa\xedda e ",r.a.createElement(f,{math:"v_k"})," a incerteza associada a medi\xe7\xe3o da sa\xedda. Da mesma forma, $v_k$ \xe9 assumido como sendo gaussiano, com m\xe9dia nula e ",r.a.createElement(f,{math:"w_k"})," e ",r.a.createElement(f,{math:"v_k"})," n\xe3o possuem correla\xe7\xe3o. Para este caso, o filtro de Kalman pode ser implementado por:",r.a.createElement(p.BlockMath,{math:"\r \\begin{aligned}\r \\hat{x}_{k+1|k} &= A\\hat{x}_{k|k}+Bu_{k}\\\\\r P_{k+1|k}&=AP_{k|k} A^T+Q\\\\\r K_k&=P_{k+1|k} C^T(R +CP_{k+1|k} C^T)^{-1} \\\\\r \\hat{x}_{k+1|k+1} &=\\hat{x}_{k+1|k}+K_k(y_{k+1}-C\\hat{x}_{k+1|k}) \\\\\r P_{k+1|k+1}&= (I-K_kC)P_{k+1|k}(I-K_kC)^T+K_kRK_k^T \r \\end{aligned}"}),r.a.createElement("p",null,"Com ",r.a.createElement(f,{math:"P \\in \\mathbb{R}^{n\\times n}"})," sendo a matriz de covari\xe2ncia da estimativa, ",r.a.createElement(f,{math:"K \\in \\mathbb{R}^{m\\times n}"})," o ganho \xf3timo de Kalman, ",r.a.createElement(f,{math:"Q \\in \\mathbb{R}^{n\\times n}"})," a matriz de covari\xe2ncia do modelo, ",r.a.createElement(f,{math:"R \\in \\mathbb{R}^{m\\times m}"})," a matriz de covari\xe2ncia das entradas, ",r.a.createElement(f,{math:"I \\in  \\mathbb{R}^{n \\times n}"})," \xe9 a matriz identidade de dimens\xe3o compt\xedvel e ",r.a.createElement(f,{math:"\\hat{x}_k"})," \xe9 o vetor de estimativas dos estados no instante ",r.a.createElement(f,{math:"k"}),". O Filtro de Kalman funciona em duas etapas, chamadas de predi\xe7\xe3o e corre\xe7\xe3o. Na etapa de predi\xe7\xe3o o filtro gera uma estimativa ",r.a.createElement("i",null,"a priori")," do vetor de estados, e na etapa de corre\xe7\xe3o, caso dispon\xedvel, o filtro toma uma medi\xe7\xe3o provinda de um sensor e faz a atualiza\xe7\xe3o, gerando uma estimativa ",r.a.createElement("i",null,"a posteriori"),". Note que nas equa\xe7\xf5es do filtro, a nota\xe7\xe3o k+1|k indica o instante $k+1$ ",r.a.createElement("i",null,"a priori"),", ou seja, n\xe3o possuindo ainda uma medi\xe7\xe3o, enquanto a nota\xe7\xe3o k+1|k+1 indica o instante k+1 dado que j\xe1 \xe9 conhecido uma medi\xe7\xe3o. O ciclo de funcionamento do filtro \xe9 ilustrado na Figura 2."),r.a.createElement(_,{src:"https://2.bp.blogspot.com/-gF3dW3XMZLE/WV7fa-0sBLI/AAAAAAAAAWA/y8jpvSb5ngYka6SS4QW00z_dlTPvBvAXQCLcBGAs/s320/predicao.png",alt:"Etapas do Filtro de Kalman",legend:"Figura 2 - Filtro de Kalman"}),r.a.createElement("p",null,"As matrizes ",r.a.createElement(f,{math:"Q"})," e ",r.a.createElement(f,{math:"R"}),' s\xe3o par\xe2metros de sintonia do filtro de Kalman, no qual possibilitam fazer com que ele passe a "confiar" mais na modelagem, conforme ilustrado na Figura 3, ou na medi\xe7\xe3o, conforme ilustrado na Figura 4. As respectivas figuras apresentam as Fun\xe7\xf5es de Densidade de Probabilidade (FDP) da sa\xedda do modelo, das medi\xe7\xf5es e da sa\xedda do Filtro de Kalman. Para ilustrar o comportamento do filtro, suponha a matriz ',r.a.createElement(f,{math:"Q=qI"})," e a matriz ",r.a.createElement(f,{math:"R=rI"}),", sendo ",r.a.createElement(f,{math:"I"})," a matriz identidade de dimens\xe3o comp\xe1tivel e ",r.a.createElement(f,{math:"q,r \\in \\mathbb{R}"}),". Note que para o caso no qual ",r.a.createElement(f,{math:"q<r"}),", a FDP do Filtro de Kalman est\xe1 mais pr\xf3xima da FDP do modelo. Ou seja, nesse caso, o filtro est\xe1 tendendo a gerar sa\xeddas pr\xf3ximas as do modelo. E no caso que ",r.a.createElement(f,{math:"q>r"}),", o filtro apresenta uma FDP mais pr\xf3xima da FDP das medidas. Assim a sa\xedda do filtro tende a gerar valores pr\xf3ximos aos medidos."),r.a.createElement(_,{src:"https://2.bp.blogspot.com/--KLJOSzaIhI/WV7gPsqjMKI/AAAAAAAAAWE/UjdyAw1ToOgbsD2osrlHaYFLU1maoV0YwCLcBGAs/s320/kalman_q.jpg",alt:"Confian\xe7a do filtro",legend:"Figura 3 - Maior confian\xe7a no modelo."}),r.a.createElement(_,{src:"https://2.bp.blogspot.com/-xBBvXPJZYPs/WV7gPuUxFqI/AAAAAAAAAWI/id0-JAHpvuIofQ2b3s527-EMv4vBoFFIQCLcBGAs/s320/kalman_r.jpg",alt:"Confian\xe7a do filtro",legend:"Figura 4 - Maior confian\xe7a na medi\xe7\xe3o."}),r.a.createElement("p",null,"O objetivo principal deste trabalho \xe9 apresentar de forma did\xe1tica as principais etapas de implementa\xe7\xe3o de um sistema de rastreamento de objetos em tempo real. Fazendo uso de abordagens encontradas na literatura. Para aquisi\xe7\xe3o da imagem, \xe9 utilizado uma c\xe2mera de baixo custo (",r.a.createElement("i",null,"webcam"),") e a plataforma de programa\xe7\xe3o Matlab\xae, no qual j\xe1 conta com diversas ferramentas para processamento de imagens. O sistema de rastreamento apresentado visa rastrear o maior objeto na cor vermelha presente na cena. E ainda lidar tamb\xe9m com situa\xe7\xf5es de r\xe1pidas oclus\xf5es, parciais ou totais, atrav\xe9s do uso do Filtro de Kalman."),r.a.createElement("h3",null,"SEGMENTA\xc7\xc3O DA IMAGEM"),r.a.createElement("p",null,"Conforme mencionado anteriormente para todo algoritmo de rastreamento de objetos em vis\xe3o computacional, existe um est\xe1gio de segmenta\xe7\xe3o, de forma a identificar em cada quadro, provindo da c\xe2mera, a posi\xe7\xe3o do objeto. Uma das estrat\xe9gias mais simples para a identifica\xe7\xe3o de objetos numa cena \xe9 atrav\xe9s de um processo de limiariza\xe7\xe3o. A limiariza\xe7\xe3o \xe9 uma das abordagens mais importantes da segmenta\xe7\xe3o de imagens. O princ\xedpio da limiariza\xe7\xe3o consiste em separar as regi\xf5es da imagem em duas classes, o fundo (",r.a.createElement("i",null,"background"),") e o objeto (",r.a.createElement("i",null,"target"),") (ARTERO and TOMMASELLI, 2000).Neste trabalho foi optado por trabalhar com imagens no espa\xe7o RGB (",r.a.createElement("i",null,"Red, Green e Blue"),"). Por ser este trabalho voltado para aplica\xe7\xf5es em tempo real, o espa\xe7o de cores RGB demonstra-se computacionalmente menos custoso, pois em geral, os dispositivos de aquisi\xe7\xe3o de imagens j\xe1 trabalham neste padr\xe3o, n\xe3o sendo necess\xe1rio uma etapa de transforma\xe7\xe3o de espa\xe7o de cores. Assim as imagens obtidas pelo dispositivo de captura s\xe3o em geral formadas por tr\xeas canais de cores, representadas por matrizes. Sendo que as entradas das matrizes s\xe3o respectivamente a informa\xe7\xe3o relativa ao vermelho, verde e azul para cada ",r.a.createElement("i",null,"pixel"),", conforme ilustrado na Figura 5."),r.a.createElement(_,{src:"https://2.bp.blogspot.com/--w3ugv-udTs/WV7hd-7ZFNI/AAAAAAAAAWQ/M4cYdEph-yIwHy2ko6LT4kmAJkOFx7nUACLcBGAs/s320/rgb.png",alt:"imagem rgb",legend:"Figura 5 - Imagem RGB."}),r.a.createElement("p",null,"A estrat\xe9gia de limiariza\xe7\xe3o adotada neste trabalho foi a subtra\xe7\xe3o dos canais de cores verde e azul do canal de cor vermelho, uma vez que busca-se rastrear os objetos na cor vermelha presente na cena. E ent\xe3o considerou-se um valor limiar (",r.a.createElement("i",null,"threshold"),"), de forma que os ",r.a.createElement("i",null,"pixels")," resultantes com valores inferiores a este limiar s\xe3o descartados e os ",r.a.createElement("i",null,"pixels")," com valores maiores s\xe3o considerados como parte do objeto a ser rastreado, conforme apresentado na Figura 6."),r.a.createElement(_,{src:"https://4.bp.blogspot.com/-pnYFUlaJSms/WV7ibAa9MBI/AAAAAAAAAWY/nizRhmsKjTUn6y0rjASWBKx82LuQLNbfACLcBGAs/s320/limiar.png",alt:"Limiariza\xe7\xe3o",legend:"Figura 6 - Limiariza\xe7\xe3o."}),r.a.createElement("i",null,"Obs: O valor de ",r.a.createElement(f,{math:"L"})," foi obtido empiricamente, atrav\xe9s de v\xe1rios testes. At\xe9 chegar no valor ideal para as condi\xe7\xf5es de ilumina\xe7\xe3o no qual a c\xe2mera se encontrava no momento da implementa\xe7\xe3o."),r.a.createElement("p",null,"Como resultado da limiariza\xe7\xe3o \xe9 obtido uma imagem bin\xe1ria, ou seja, cujo os ",r.a.createElement("i",null,"pixels")," possuem valores de 0 ou 1, resultando em uma imagem do tipo preto e branca, no qual a regi\xe3o branca representa o objeto vermelho presente na cena. Na Figura 7 \xe9 apresentado o resultado obtido."),r.a.createElement(_,{src:"https://3.bp.blogspot.com/-hO9_WqmaZUg/WV7itsUjNGI/AAAAAAAAAWc/34FZnxTwtXEZ4eJnJUeWSkv4daxUOPEeACLcBGAs/s320/bin.png",alt:"Resultado",legend:"Figura 7 - Resultado da Limiariza\xe7\xe3o."}),r.a.createElement("h4",null,"Tratando dois objetos vermelhos na cena"),r.a.createElement("p",null,"Uma situa\xe7\xe3o poss\xedvel no qual \xe9 desejado que o algoritmo apresente robustez, \xe9 no caso de existirem dois objetos na cor vermelha presente na imagem, ou mesmo a presen\xe7a de pequenos detalhes vermelhos no fundo da imagem. O resultado da limiariza\xe7\xe3o para este caso, possui duas ou mais regi\xf5es brancas conforme a Figura 8, no qual apresenta o resultado da limiariza\xe7\xe3o quando \xe9 posicionado dois objetos vermelhos diante da c\xe2mera."),r.a.createElement(_,{src:"https://1.bp.blogspot.com/-HugKp3SFnYo/WV7jDSoUkTI/AAAAAAAAAWg/NGsh3PWAebo0XRJC5SFmx6LYn27jLCdpgCLcBGAs/s320/bin_multo.png",alt:"Limiariza\xe7\xe3o com dois objetos",legend:"Figura 8 - Limiariza\xe7\xe3o com dois objetos."}),r.a.createElement("p",null,"O objetivo deste trabalho \xe9 rastrear o maior objeto vermelho presente na cena. Portanto, faz-se necess\xe1rio a implementa\xe7\xe3o de um mecanismo para buscar a posi\xe7\xe3o do maior objeto vermelho. Visando o m\xednimo de consumo computacional, de forma a garantir um bom funcionamento em tempo real, foi implementado o algoritmo que faz a acumula\xe7\xe3o dos ",r.a.createElement("i",null,"pixels")," da imagem bin\xe1ria, tanto na horizontal, como na vertical. Define-se a imagem bin\xe1ria como sendo uma matriz ",r.a.createElement(f,{math:"O \\in \\mathbb{N}^{N\\times M}"})," definida como ",r.a.createElement(f,{math:"O = \\{o_{ij}\\}"}),", com ",r.a.createElement(f,{math:"1\\leq i \\leq N"})," e ",r.a.createElement(f,{math:"1\\leq j\r \\leq M"}),", cuja entradas s\xe3o 0 ou 1. O vetor de acumula\xe7\xe3o horizontal ",r.a.createElement(f,{math:"H \\in \\mathbb{N}^N"})," \xe9 definido como:",r.a.createElement(p.BlockMath,{math:"\r \\begin{aligned}H=[h_1~h_2~\\cdots~ h_N]^T ,\\quad h_i=\\sum_{j=1}^{M}o_{ij}, \\quad\r i=1,2,\\ldots,N\\end{aligned}"}),"E o vetor de acumula\xe7\xe3o vertical ",r.a.createElement(f,{math:"V \\in \\mathbb{N}^M"}),"como:"),r.a.createElement(p.BlockMath,{math:"\r \\begin{aligned}V=[v_1~v_2~\\cdots~ v_M]^T ,\\quad v_j=\\sum_{i=1}^{N}o_{ij}, \\quad\r j=1,2,\\ldots,M\\end{aligned}"}),r.a.createElement("p",null,"Dessa forma, o ponto ",r.a.createElement(f,{math:"(x_{max},y_{max})"})," com a maior concentra\xe7\xe3o de pixels vermelhos na imagem \xe9 dado por:"),r.a.createElement(p.BlockMath,{math:"\r \\begin{aligned}x_{max}=max(V), \\quad\r y_{max}=max(H)\\end{aligned}"}),r.a.createElement("p",null,"Na Figura 9 \xe9 ilustrado a acumula\xe7\xe3o dos ",r.a.createElement("i",null,"pixels")," da imagem bin\xe1ria e os respectivos pontos de m\xe1ximo, que coincidem com o ponto na imagem que cont\xe9m a maior concentra\xe7\xe3o de",r.a.createElement("i",null,"pixels")," vermelhos."),r.a.createElement(_,{src:"https://1.bp.blogspot.com/-btt2yn24EY4/WV7jXqyCaPI/AAAAAAAAAWk/o_w3fjIhM2wIqeWjF-LIFgLZtPm12ULswCLcBGAs/s320/acumulacao.png",alt:"Acumula\xe7\xe3o",legend:"Figura 9 - Acumula\xe7\xe3o"}),r.a.createElement("p",null," Ap\xf3s a identifica\xe7\xe3o da regi\xe3o onde possui o maior objeto vermelho na cena, define-se uma regi\xe3o de interesse, formada considerando-se o intervalo de $10\\%$, para cima, para baixo e para os lados, em torno do ponto",r.a.createElement(f,{math:"(x_{max},y_{max})"}),". Em seguida \xe9 determinado a coordenada ",r.a.createElement(f,{math:"(x_{c},y_{c})"})," do objeto aplicando-se o c\xe1lculo do centro geom\xe9trico na regi\xe3o de interesse, atrav\xe9s das equa\xe7\xf5es:"),r.a.createElement(p.BlockMath,{math:"      \r \\begin{aligned}\r x_c &=\\frac{\\sum_{i=1}^{N}o_{ij}i}{\\sum_{i=1}^{N}\\sum_{j=1}^{M}o_{ij}}\\\\\r y_c &=\\frac{\\sum_{i=1}^{M}o_{ij}j}{\\sum_{i=1}^{N}\\sum_{j=1}^{M}o_{ij}}\r \\end{aligned}"}),r.a.createElement("h3",null,"TRATAMENTO DE OCLUS\xd5ES"),r.a.createElement("p",null,"Note que para o caso no qual \xe9 poss\xedvel visualizar o objeto na cena, o procedimento apresentado na se\xe7\xe3o anterior \xe9 suficiente para fazer o rastreamento. Por\xe9m, caso este objeto sofra uma oclus\xe3o, o procedimento descrito falha em buscar as coordenadas do objeto. Para contornar este problema, foi tomado como ferramenta o Filtro de Kalman e ent\xe3o, nas situa\xe7\xf5es de oclus\xe3o, n\xe3o mais \xe9 feito o processamento da imagem, mas \xe9 gerado estimativas da posi\xe7\xe3o do objeto baseando-se no ultimo instante no qual foi poss\xedvel visualizar o objeto.Para implementar o Filtro de Kalman deve-se considerar um modelo para a din\xe2mica do movimento do objeto, neste trabalho optou-se por utilizar o modelo linear dado por:"),r.a.createElement(p.BlockMath,{math:"\r \\begin{aligned}\r \\left[\r \\begin{array}{cccc}\r \\hat{x}_1(k+1) \\\\ \r \\hat{x}_2(k+1) \\\\ \r \\hat{x}_3(k+1) \\\\ \r \\hat{x}_4(k+1)\r \\end{array} \\right] =\\left[ \\begin{array}{cccc}\r 1 & 0 & \\Delta t & 0 \\\\\r 0 & 1 & 0 & \\Delta t \\\\\r 0 & 0 & 1 & 0\\\\\r 0 & 0 & 0 & 1\r \\end{array} \\right] \\left[ \\begin{array}{cccc}\r \\hat{x}_1(k) \\\\\r \\hat{x}_2(k) \\\\\r \\hat{x}_3(k) \\\\\r \\hat{x}_4(k)\\end{array} \\right]+\\left[ \\begin{array}{cccc}\r \\frac{1}{2}\\Delta t^2 & 0 \\\\\r 0 & \\frac{1}{2}\\Delta t^2\\\\\r \\Delta t & 0 \\\\\r 0 & \\Delta t \\\\\r \\end{array} \\right]\\left[\r \\begin{array}{cccc}\r u_1(k) \\\\\r u_2(k) \\end{array} \\right],\\\\\r \\left[\r \\begin{array}{cccc}\r z_1(k) \\\\\r z_2(k)\\end{array} \\right]=\\left[\r \\begin{array}{cccc}\r 1 & 0 & 0 & 0 \\\\\r 0 & 1 & 0 & 0\\end{array} \\right]\\left[ \\begin{array}{cccc}\r \\hat{x}_1(k) \\\\\r \\hat{x}_2(k) \\\\\r \\hat{x}_3(k) \\\\\r \\hat{x}_4(k) \\end{array}\r \\right]\\end{aligned}"}),r.a.createElement("p",null,"Sendo que ",r.a.createElement(f,{math:"\\hat{x}_1=\\hat{x}_c"})," \xe9 a estimativa da coordenada horizontal, ",r.a.createElement(f,{math:"\\hat{x}_2=\\hat{y}_c"})," \xe9 a estimativa da coordenada vertical, ",r.a.createElement(f,{math:"\\hat{x}_3=\\hat{v}_x"})," \xe9 a estimativa da velocidade na horizontal, ",r.a.createElement(f,{math:"\\hat{x}_4=\\hat{v}_y"})," \xe9 a estimativa da velocidade na vertical, ",r.a.createElement(f,{math:"u_1=a_x"})," \xe9 a acelera\xe7\xe3o horizontal e ",r.a.createElement(f,{math:"u_2=a_y"})," \xe9 a acelera\xe7\xe3o vertical. Note que o modelo descreve um movimento retil\xedneo uniformemente variado (MURV) e o $\\Delta t$ presente, indica o tempo de amostragem, que para este caso, \xe9 o tempo no qual o Matlab\xae leva para processar cada quadro da cena."),r.a.createElement("i",null,"Obs: Os valores de ",r.a.createElement(f,{math:"a_x"})," e ",r.a.createElement(f,{math:"a_y"})," s\xe3o obtidos atrav\xe9s dos frames anteriores, fazendo aproxima\xe7\xe3o da derivada segunda da posi\xe7\xe3o."),r.a.createElement("p",null,'Com o modelo definido, pode-se aplicar as equa\xe7\xf5es do Filtro de Kalman apresentadas na introdu\xe7\xe3o e ent\xe3o gerar estimativas para a posi\xe7\xe3o do objeto vermelho. Por\xe9m, como \xe9 desejado o tratamento de oclus\xf5es, foi optado por utilizar n\xe3o apenas um, mas dois Filtros de Kalman, sendo que o primeiro \xe9 sintonizado para ter "confian\xe7a" na medi\xe7\xe3o. E o segundo "confian\xe7a" no modelo. Assim obt\xeam-se um algoritmo com maior robustez. A Figura 10 apresenta o diagrama conceitual da estrutura utilizada.'),r.a.createElement(_,{src:"https://1.bp.blogspot.com/-XpoyRu0bpdc/WV7jsc2OIlI/AAAAAAAAAWo/pZh80J0V2LQqaG3vI_MHqad1PTcIiyIAwCLcBGAs/s320/diagram.png",alt:"estrutura",legend:"Figura 10 - Estrutura."}),r.a.createElement("p",null,"Note que a sa\xedda passa a ser ",r.a.createElement(f,{math:"Y_1"})," e ",r.a.createElement(f,{math:"Y_2"}),', que s\xe3o selecionadas conforme a detec\xe7\xe3o ou n\xe3o de oclus\xf5es. Nos instantes em que n\xe3o existe oclus\xe3o, a sa\xedda \xe9 aquela provinda do Filtro de Kalman que "confia" mais na medi\xe7\xe3o. E quando verifica-se uma oclus\xe3o, \xe9 selecionado a sa\xedda do Filtro de Kalman que "confia" mais no modelo. Esta estrat\xe9gia foi necess\xe1ria pois, o filtro sintonizado para confiar no modelo apresenta bons resultados nas situa\xe7\xf5es de oclus\xe3o, por\xe9m uma baixa efici\xeancia na situa\xe7\xf5es sem oclus\xe3o e vice-versa.'),r.a.createElement("h3",null,"RESULTADO"),"O resultado obtido pelo algoritmo de rastreamento desenvolvido \xe9 apresentado nesta se\xe7\xe3o. Para situa\xe7\xf5es sem oclus\xe3o, o resultado \xe9 conforme apresentado na Figura 11.",r.a.createElement(_,{src:"https://4.bp.blogspot.com/-yAXdYw8HpeI/WV7j6jeVzHI/AAAAAAAAAWs/cgOV-Jz_lqYWKwdVxT8POMYlABE7guPJQCLcBGAs/s320/frame_so.png",alt:"sem oclus\xe3o",legend:"Figura 11 - Sem oclus\xe3o."}),"Para as situa\xe7\xf5es com oclus\xe3o, o resultado \xe9 apresentado na Figura 12.",r.a.createElement(_,{src:"https://1.bp.blogspot.com/-DESUcQuAcL0/WV7kHCAeJzI/AAAAAAAAAWw/QNZ-F05mHA0QI_gjyHi_Ao0_g0v-Ti5qACLcBGAs/s320/frame_co.png",alt:"Com oclus\xe3o",legend:"Figura 12 - Com oclus\xe3o"}),'Nos instantes em que n\xe3o \xe9 poss\xedvel visualizar o objeto, \xe9 tomado os valores obtidos pelo Filtro de Kalman sintonizado para "confiar" no modelo, ent\xe3o baseando-se no ultimo instante que foi poss\xedvel visualizar o objeto, \xe9 gerado estimativas da trajet\xf3ria do objeto conforme apresentado na Figura 13.',r.a.createElement(_,{src:"https://2.bp.blogspot.com/-HTJYIdaKPfo/WV7ksya140I/AAAAAAAAAW0/mVVB5ByEcfEHSD14V-LR56SWBKW8Moj7QCLcBGAs/s320/trajetoria.jpg",alt:"trajet\xf3ria",legend:"Figura 13 - Trajet\xf3ria."}),'Note que como o modelo utilizado \xe9 linear, a estimativa obtida \xe9 de uma trajet\xf3ria retil\xednea. No entanto, para situa\xe7\xf5es sem oclus\xe3o, por ser utilizado um filtro sintonizado para "confiar" na medi\xe7\xe3o, obt\xeam-se um bom desempenho para movimentos n\xe3o-lineares, conforme apresentado na Figura 14.',r.a.createElement(_,{src:"https://2.bp.blogspot.com/-WSzLStoHZcE/WV7lE7OI4LI/AAAAAAAAAW4/x2HsJzoqSawuF4gBJ_cjsNQQQjFWFFFkACLcBGAs/s320/trajet2.jpg",alt:"n\xe3o-linear",legend:"Figura 14 - Movimentos n\xe3o-lineares"}),r.a.createElement("h3",null,"V\xcdDEO DEMONSTRA\xc7\xc3O"),r.a.createElement("center",null,r.a.createElement("iframe",{allowfullscreen:"",class:"YOUTUBE-iframe-video","data-thumbnail-src":"https://i.ytimg.com/vi/tREbIw9DxHA/0.jpg",frameborder:"0",height:"480",src:"https://www.youtube.com/embed/tREbIw9DxHA?feature=player_embedded",width:"650"})),r.a.createElement("h3",null,"C\xd3DIGO FONTE"),r.a.createElement("center",null,r.a.createElement("a",{href:"https://github.com/Marofe/Object-Tracking/blob/master/kalman_live.m"},"https://github.com/Marofe/Object-Tracking/blob/master/kalman_live.m")),r.a.createElement("h3",null,"CONCLUS\xc3O"),r.a.createElement("p",null,"Com o desenvolvimento deste trabalho foi poss\xedvel verificar na pr\xe1tica o desempenho do Filtro de Kalman para estimar a trajet\xf3ria de objetos com situa\xe7\xf5es no qual existe falta de informa\xe7\xe3o. Tamb\xe9m foi apresentado os principais detalhes de implementa\xe7\xe3o do sistema de vis\xe3o computacional, voltando-se para a \xe1rea de rastreamento de objetos. Mostrou-se que \xe9 poss\xedvel obter um desempenho satisfat\xf3rio para rastreamento de objetos em cenas obtidas por uma c\xe2mera de baixo custo, mesmo com a presen\xe7a de mais de um objeto da mesma cor. O algoritmo apresentou boa efici\xeancia para situa\xe7\xf5es de r\xe1pidas oclus\xf5es observou-se que este projeto ilustra de forma simples o potencial do Filtro de Kalman e sua relativa simplicidade de implementa\xe7\xe3o."),r.a.createElement("h3",null,"REFER\xcaNCIAS"),r.a.createElement("p",null,r.a.createElement("b",null,"ARTERO, A. and TOMMASELLI, A. (2000)"),". Limiariza\xe7\xe3o autom\xe1tica de imagens digitais, Boletim de Ci\xeancias Geod\xe9sicas 6(1): 38\u201348."),r.a.createElement("p",null,r.a.createElement("b",null,"Freitas, G. M. et al. (2010)"),". Rastreamento de objetos em v\xeddeos e separa\xe7\xe3o em classes."),r.a.createElement("p",null,r.a.createElement("b",null,"Funk, N. (2003)"),". A study of the kalman filter applied to visual tracking, University of Alberta, Project for CMPUT 652(6)."),r.a.createElement("p",null,r.a.createElement("b",null,"Iraei, I. and Faez, K. (2015)"),". Object tracking with occlusion handling using mean shift, kalman filter and edge histogram, Pattern Recognition and Image Analysis (IPRIA), 2015 2nd International Conference on, IEEE, pp. 1\u20136."),r.a.createElement("p",null,r.a.createElement("b",null,"Kalman, R. E. et al. (1960)"),". A new approach to linear filtering and prediction problems, Journal of basic Engineering 82(1): 35\u201345."),r.a.createElement("p",null,r.a.createElement("b",null,"Pinho, R. R., Tavares, J. M. R. S. and Correia, M. F. P. V. (2004).")," Introdu\xe7\xe3o \xe0 an\xe1lise de movimento usando vis\xe3o computacional."),r.a.createElement("p",null,r.a.createElement("b",null,"Relli, C. (2014)"),". Caracteriza\xe7\xe3o de algoritmos de rastreamento de objetos em video considerando situa\xe7\xf5es de oclus\xe3o, RETEC-Revista de Tecnologias 6(1)."),r.a.createElement("p",null,r.a.createElement("b",null,"Van den Bergh, M. and Van Gool, L. (2011)"),". Combining rgb and tof cameras for real-time 3d hand gesture interaction, Applications of Computer Vision (WACV), 2011 IEEE Workshop on, IEEE,p. 66\u201372."),r.a.createElement("p",null,r.a.createElement("b",null,"WANGENHEIM, A. v. et al. (2001)"),". Seminario introdu\xe7\xe3o a vis\xe3o computacional, Vis\xe3o Computacional Aldon von Wangenheim\u2019s HomePage."),r.a.createElement("p",null,r.a.createElement("b",null,"Welch, G. and Bishop, G. (1995)"),". An introduction to the kalman filter."),r.a.createElement("p",null,r.a.createElement("b",null,"Weng, S.-K., Kuo, C.-M. and Tu, S.-K. (2006)"),". Video object tracking using adaptive kalman filter,Journal of Visual Communication and Image Representation 17(6): 1190\u20131208."),r.a.createElement(k.a.DiscussionEmbed,{shortname:"marofe-github-io",config:{url:"https://marofe.github.io/?p=tutorials/rastreamento_usando_visao_filtro_kalman",identifier:"rastreamento_usando_visao_filtro_kalman",title:"Rastreamento de Objetos usando Vis\xe3o Computacional e Filtro de Kalman"}}))},x=function(e){return r.a.createElement("div",{className:"divPage"},r.a.createElement("div",{class:"listCell"},r.a.createElement("h2",null,r.a.createElement("a",{href:"/tutorials/rastreamento_usando_visao_filtro_kalman"},"Rastreamento de objetos usando Vis\xe3o Computacional e Filtro de Kalman")),r.a.createElement("p",null,"Este trabalho apresenta um algoritmo em tempo real para rastreamento de objetos em vis\xe3o computacional, usando o Filtro de Kalman como mecanismo de predi\xe7\xe3o para situa\xe7\xf5es de oclus\xe3o e ou contamina\xe7\xe3o da cena por ru\xeddo. O principal objetivo deste trabalho \xe9 de apresentar de forma did\xe1tica o desenvolvimento de um algoritmo de rastreamento de objetos baseado em cor. O algoritmo apresentado faz o rastreamento do maior objeto sim\xe9trico de uma cor pr\xe9-definida presente na cena. \xc9 apresentado em detalhes a implementa\xe7\xe3o da etapa de segmenta\xe7\xe3o da imagem, e posteriormente \xe9 apresentado uma estrat\xe9gia para tratar situa\xe7\xf5es com dois objetos da mesma cor. Por fim \xe9 demonstrado o uso do Filtro de Kalmam."),r.a.createElement("p",null,"\xdaltima atualiza\xe7\xe3o:  13 de Dezembro de 2015.")))},A=function(){return r.a.createElement("div",{className:"divPage"},r.a.createElement(d.a,null,r.a.createElement("title",null,"Tutorials | Marcos Rog\xe9rio Fernandes"),r.a.createElement("meta",{name:"description",content:"Here you will find some of my tutorials and toy examples. "})),r.a.createElement("div",{className:"top"},r.a.createElement("h1",null,"Tutorials")),r.a.createElement(s.a,{path:"/tutorials",exact:!0,render:function(e){return r.a.createElement(x,null)}}),r.a.createElement(s.a,{path:"/tutorials/rastreamento_usando_visao_filtro_kalman",exact:!0,render:function(e){return r.a.createElement(v,null)}}))},w=t(27),y=t(28),F=t(30),M=t(29),P=t(31),q=(t(17),function(e){var a=e.notes.map(function(e){return r.a.createElement("div",{className:"listCell"},r.a.createElement("h2",null,r.a.createElement("a",{href:"/notes/"+e.link},e.title)),r.a.createElement("p",null,e.desc))});return r.a.createElement("div",null,r.a.createElement(d.a,null,r.a.createElement("title",null,"Notes | Marcos Rog\xe9rio Fernandes"),r.a.createElement("meta",{name:"description",content:"Here you will find my research notes."})),r.a.createElement("div",{className:"top"},r.a.createElement("h1",null,"My Notes"),r.a.createElement("p",null,"The following contents are some of my research notes about a few topics that I have been working on.")),a)}),R=function(e){var a={url:"https://marofe.github.io/?p="+e.note.link,identifier:"note-"+e.note.link,title:e.title};return r.a.createElement("article",null,r.a.createElement(d.a,null,r.a.createElement("title",null,e.note.title,"| Marofe"),r.a.createElement("meta",{name:"description",content:e.note.desc})),r.a.createElement("h1",null,e.title),r.a.createElement("p",null,e.desc),r.a.createElement("p",{align:"right"},"Last Update:  26 December, 2019."),r.a.createElement("div",null,"Consider a dynamic system in which its states are embedded on a Matrix Lie Group ",r.a.createElement(f,{math:"G"})," of dimension ",r.a.createElement(f,{math:"n"})," and measurements are available through a map: ",r.a.createElement(f,{math:"h:G\\rightarrow G'"}),", where ",r.a.createElement(f,{math:"G'"})," is a Matrix Lie Group of dimension ",r.a.createElement(f,{math:"m"}),", described by",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r {X}_{k+1}&= {X}_k \\exp_G([ \\Omega( {X}_k, {u}_k)+  w_k]_G^\\wedge),\\\\\r {Y}_k &=   h( {X}_k)  \\exp_{G'}([  \\nu_k]_{G'}^\\wedge)\r\n\\end{aligned}"}),"where ",r.a.createElement(f,{math:"{X}_k\\in M\\subseteq G"})," is the state and ",r.a.createElement(f,{math:"{Y}_k \\in M'\\subseteq G'"})," is the measurement. ",r.a.createElement(f,{math:"M,M'"})," are subgroups of ",r.a.createElement(f,{math:"G,G'"}),", respectively, such that the following bijection is well defined",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r \\ln_G( \\exp_G( {X}_k))&= {X}_k,\\\\\r \\ln_{G'}( \\exp_{G'}( {Y}_k))&= {Y}_k\r\n\\end{aligned}"}),"and ",r.a.createElement(f,{math:"w_k\\sim \\mathcal{N}(0,Q_k)"})," and ",r.a.createElement(f,{math:"\\nu_k\\sim \\mathcal{N}(0,R_k)"}),".",r.a.createElement("center",null,r.a.createElement("h2",null,"Filtering")),r.a.createElement("b",null,"Prediction:"),r.a.createElement(p.BlockMath,{math:"\r\n\\begin{aligned}\r {\\hat{X}}_{k+1|k}&= {\\hat{X}}_{k|k}\\exp_G([\\hat{\\Omega}_k]_G^\\wedge)\\\\\r\nP_{k+1|k}&=\\mathscr{F}_kP_{k|k}\\mathscr{F}_k^{\\intercal}+\\Phi(\\hat{\\Omega}_k)Q_k\\Phi(\\hat{\\Omega}_k)^\\intercal\r\n\\end{aligned}"}),"where",r.a.createElement(p.BlockMath,{math:"\r\n\\begin{aligned}\r\n\\hat{\\Omega}_k&=\\Omega_k( {\\hat{X}}_{k|k},u_k)\\\\\r\n\\mathscr{F}_k&=Ad_G(\\exp_G([-\\hat\\Omega_k]_G^\\wedge))+\\Phi(\\hat\\Omega_k)\\mathscr{C}_k\\\\\r\n\\mathscr{C}_k&=\\frac{\\partial}{\\partial \\epsilon}\\Omega_k( {\\hat{X}}_{k|k}\\exp_G([\\epsilon]_G^\\wedge),u_k)|_{\\epsilon=0}\\\\\r\n\\Phi(a)&=\\sum_{m=0}^\\infty \\frac{(-1)^m}{(m+1)!}ad_G(a)^m\r\n\\end{aligned}"}),r.a.createElement("b",null,"Update:"),r.a.createElement(p.BlockMath,{math:"\r\n\\begin{aligned}\r\nK&=P_{k+1|k}\\mathscr{H}^\\intercal(R+\\mathscr{H}_kP_{k+1|k}\\mathscr{H}_k^T)^{-1}\\\\\r\nv_k&=K\\ln_{G'}(h( {\\hat{X}}_{k+1|k})^{-1}y_{k+1})^\\vee_{G'}\\\\\r {\\hat{X}}_{k+1|k+1}&= {\\hat{X}}_{k+1|k} \\exp([v_k]_G^\\wedge)\\\\\r\nP_{k+1|k+1}&=\\Phi(v_k)(I-K\\mathscr{H}_k)P_{k+1|k}\\Phi(v_k)^\\intercal\r\n\\end{aligned}"}),"where",r.a.createElement(p.BlockMath,{math:"\r\n\\begin{aligned}\r\n\\mathscr{H}_k=\\frac{\\partial}{\\partial \\epsilon}\\left[ \\ln_{G'}(h( {\\hat{X}}_{k+1|k})^{-1}h( {\\hat{X}}_{k+1|k} \\exp([ \\epsilon]^\\wedge_{G})))\\right]^{\\vee}_{G'}\\big|_{ \\epsilon=0}\r\n\\end{aligned}"})),r.a.createElement(k.a.DiscussionEmbed,{shortname:"marofe-github-io",config:a}))},I=function(e){var a={url:"https://marofe.github.io/?p="+e.note.link,identifier:"note-"+e.note.link,title:e.title};return r.a.createElement("article",null,r.a.createElement(d.a,null,r.a.createElement("title",null,e.note.title," | Marofe"),r.a.createElement("meta",{name:"description",content:e.note.desc})),r.a.createElement("h1",null,e.title),r.a.createElement("p",null,e.desc),r.a.createElement("p",{align:"right"},"Last Update:  25 Fev, 2020."),r.a.createElement("div",null,r.a.createElement("h2",null,"The Differential Riccati Equation"),"The selection of optimal control law and the design of optimal filters require the solving of a Riccati Equation. So, Riccati type equations emerge naturally on control and filtering problems of  dynamic systems. To find solutions for Riccati Equations, it is convenient to make subdivisions based on the nature of the coefficient matrices and the time interval considered.",r.a.createElement("ul",null,r.a.createElement("li",null,"Time-varying coefficients; ",r.a.createElement(f,{math:"t_1<\\infty"})),r.a.createElement("li",null,"Time-varying coefficients; ",r.a.createElement(f,{math:"t_1\\rightarrow \\infty"})),r.a.createElement("li",null,"Constant coefficients; ",r.a.createElement(f,{math:"t_1<\\infty"})),r.a.createElement("li",null,"Constant coefficient; ",r.a.createElement(f,{math:"t_1\\rightarrow \\infty"}))),"In particular, we restrict attention to the Riccati equation occurring to a situation when a boundary condition will be given at ",r.a.createElement(f,{math:"t_1"})," with the solution desired for ",r.a.createElement(f,{math:"t\\le t_1"}),'.  Recall that the Riccati Equation in the context of the control problem runs "backward" in time.',r.a.createElement(_,{src:"/images/p_finite.svg",width:"50%"}),"The following results are based on the book ",r.a.createElement("b",null,r.a.createElement("a",{href:"#Anderson1971"},"[Anderson1971]")),". It shows that in all four cases, it is possible to replace the problem of solving the ",r.a.createElement("i",null,"nonlinear")," Riccati differential equation by the problem of solving a ",r.a.createElement("i",null,"linear")," differential equation and then computing a matrix inverse.",r.a.createElement("h3",null,"Time-Varying Coeff. and Finite Horizon"),"Consider the differential Riccati equation for ",r.a.createElement(f,{math:"t \\le t_1"})," of the form",r.a.createElement(p.BlockMath,{math:"\r\n\\begin{aligned}\r -\\dot{P}=P(t)F(t)+F(t)^\\intercal P(t)-P(t)G(t)R^{-1}(t)G(t)^\\intercal P(t)+Q(t)\r\n\\end{aligned}"}),"and the following assumptions:",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\nP(t_1)&=P_1=P_1^\\intercal \\ge 0,\\\\\r\nQ(t)&=Q(t)^\\intercal \\ge 0,\\\\\r\nR(t)&=R(t)^\\intercal >0.\r\n\\end{aligned}"}),"Associated with the ",r.a.createElement("i",null,"Nonlinear Differential Riccati Equation")," we define an augmented ",r.a.createElement("i",null,"linear")," differential equation",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r \\left[\r \\begin{matrix}\r \\dot{X}(t)\\\\\r \\dot{Y}(t)\r \\end{matrix}\r \\right]=\\left[\r \\begin{matrix}\r F(t) & -G(t)R^{-1}(t)G(t)^\\intercal \\\\\r -Q(t) & -F(t)^\\intercal\r \\end{matrix}\r \\right]\\left[\r \\begin{matrix}\r X(t)\\\\\r Y(t)\r \\end{matrix}\r \\right],\\quad \\left[\r \\begin{matrix}\r X(t_1)\\\\\r Y(t_1)\r \\end{matrix}\r \\right]=\\left[\r \\begin{matrix}\r I\\\\\r P_1\r \\end{matrix}\r \\right].\r\n\\end{aligned}"}),r.a.createElement("div",{className:"lemma"},r.a.createElement("b",null,"Lemma:"),r.a.createElement("br",null),"If the solution exists on ",r.a.createElement(f,{math:"[t,t_1]"})," then the solution of the linear counter-part has the property that ",r.a.createElement(f,{math:"X^{-1}(t)"})," exists and",r.a.createElement(p.BlockMath,{math:"\t\\begin{aligned}\r P(t)=Y(t)X^{-1}(t).\r\n\\end{aligned}"})),r.a.createElement("div",{className:"proof"},r.a.createElement("b",null,"Proof:"),r.a.createElement("br",null),"By the ",r.a.createElement("i",null,"product rule")," and ",r.a.createElement("i",null,"inverse rule")," of matrix calculus, one have",r.a.createElement(p.BlockMath,{math:"\t\\begin{aligned}\r\n\\frac{d}{dt}[Y(t)X^{-1}(t)]&=\\dot{Y}(t)X^{-1}(t)-Y(t)X^{-1}(t)\\dot{X}(t)X^{-1}(t).\r\n\\end{aligned}"}),"Notice that from the augmented ODE we have",r.a.createElement(p.BlockMath,{math:"\t\\begin{aligned}\r \\dot{X}(t)&=F(t)X(t)-G(t)R^{-1}(t)G(t)^\\intercal Y(t),\\\\\r \\dot{Y}(t)&=-Q(t)X(t)-F(t)^\\intercal Y(t)\r\n\\end{aligned}"}),"Thus,",r.a.createElement(p.BlockMath,{math:"\t\\begin{aligned}\r\n\\frac{d}{dt}[YX^{-1}]&=(-QX-F^\\intercal Y)X^{-1}-YX^{-1}(FX-GR^{-1}G^\\intercal Y)X^{-1}\\\\\r\n&=-QXX^{-1}-F^\\intercal YX^{-1}-YX^{-1}FXX^{-1}+YX^{-1}GR^{-1}G^\\intercal YX^{-1}\\\\\r\n&=-Q-F^\\intercal (YX^{-1})-(YX^{-1})F+(YX^{-1})GR^{-1}G^\\intercal(YX^{-1})\\\\\r\n&=-Q-F^\\intercal P-PF+PGR^{-1}G^\\intercal P\r\n\\end{aligned}"}),"where for notation simplicity we adopt ",r.a.createElement(f,{math:"X(t)=X,Y(t)=Y,Q(t)=Q,F(t)=F,G(t)=G,R(t)=R"})," and ",r.a.createElement(f,{math:"P(t)=P"}),".  As result, we conclude that",r.a.createElement(p.BlockMath,{math:"\t\\begin{aligned}\r\n-\\dot{P}=Q+F^\\intercal P+PF-PGR^{-1}G^\\intercal P.\r\n\\end{aligned}"}),"The preceding manipulations also shows that if ",r.a.createElement(f,{math:"X^{-1}(\\sigma)"})," exists for all ",r.a.createElement(f,{math:"\\sigma \\in [t,t_1]"})," then ",r.a.createElement(f,{math:"P(t)"})," exists for the same interval. Let us now check that the existence of ",r.a.createElement(f,{math:"P(t)"})," guarantees the existence of ",r.a.createElement(f,{math:"X^{-1}(t)"}),".",r.a.createElement("p",null),"Let ",r.a.createElement(f,{math:"\\Phi(\\cdot,\\cdot)"})," be the ",r.a.createElement("i",null,"Transition Matrix")," associated with the system",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r \\dot{X}=[F(t)-G(t)R^{-1}(t)G(t)^\\intercal P(t)]X(t).\r\n\\end{aligned}"}),"As long as ",r.a.createElement(f,{math:"P(t)"})," exists for ",r.a.createElement(f,{math:"t\\le t_1"})," then ",r.a.createElement(f,{math:"\\Phi(\\cdot,\\cdot)"})," is defined for all its arguments values less or equal to ",r.a.createElement(f,{math:"t_1"}),".  We claim that",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r X(t)=\\Phi(t,t_1),\\quad Y(t)=P(t)\\Phi(t,t_1).\r\n\\end{aligned}"}),"This is sufficient to prove that ",r.a.createElement(f,{math:"X^{-1}(t)"})," exists since ",r.a.createElement(f,{math:"\\Phi(t,t_1)^{-1}=\\Phi(t_1,t)"})," is known to exist. To verify the claim, we have",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\n\\begin{aligned}\r \\dot{\\Phi}&=[F-GR^{-1}G^\\intercal P]\\Phi\\\\\r &=FX-GR^{-1}G^\\intercal Y=\\dot{X}\r\n\\end{aligned}\r\n\\end{aligned}"}),"and",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r \\begin{aligned}\r \\frac{d}{dt}[P\\Phi]&=\\dot{P}\\Phi+P\\dot{\\Phi}\\\\\r\n&=-(PF+F^\\intercal P-PGR^{-1}G^\\intercal P+Q)\\Phi +P(F\\Phi-GR^{-1}G^\\intercal Y)\\\\\r\n&=-QX -F^\\intercal Y=\\dot{Y}\r \\end{aligned}\r\n\\end{aligned}"}),"Therefore, the relations ",r.a.createElement(f,{math:"X(t)=\\Phi(t,t_1),\\quad Y(t)=P(t)\\Phi(t,t_1)"})," satisfy the augmented linear ODE."),r.a.createElement("div",{className:"remark"},r.a.createElement("b",null,"Remark: "),"Another scenario that might occur is when ",r.a.createElement(f,{math:"t_1\\rightarrow \\infty"})," and the matrix coefficients are varying. In this case, an approximation for ",r.a.createElement(f,{math:"P_\\infty"})," is possible to obtain by integration of the linear ODE. However, that approximation depends on the length ",r.a.createElement(f,{math:"t_1"}),"  Thus, the approximation becomes better as ",r.a.createElement(f,{math:"t_1"})," is increased."),r.a.createElement("h3",null,"Const. Coeff and Finite Horizon (",r.a.createElement(f,{math:"t_1<\\infty"}),")"),"For this scenario, consider",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\n-\\dot{P}=P(t)F+F^\\intercal P(t)-P(t)GR^{-1}G^\\intercal P(t)+Q\r\n\\end{aligned}"}),"where ",r.a.createElement(f,{math:"F,G,R"})," and ",r.a.createElement(f,{math:"Q"})," are constant matrices. The respective augmented linear differential equation is",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\n\\left[\r\n\\begin{matrix}\r\n\\dot{X}(t)\\\\\r\n\\dot{Y}(t)\r\n\\end{matrix}\r\n\\right]=\\left[\r\n\\begin{matrix}\r\nF & -GR^{-1}G^\\intercal \\\\\r\n-Q & -F^\\intercal\r\n\\end{matrix}\r\n\\right]\\left[\r\n\\begin{matrix}\r\nX(t)\\\\\r\nY(t)\r\n\\end{matrix}\r\n\\right],\\quad \\left[\r\n\\begin{matrix}\r\nX(t_1)\\\\\r\nY(t_1)\r\n\\end{matrix}\r\n\\right]=\\left[\r\n\\begin{matrix}\r\nI\\\\\r\nP_1\r\n\\end{matrix}\r\n\\right].\r\n\\end{aligned}"}),"As long as all coefficients are constant, the closed-form solution is",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\n\\left[\r\n\\begin{matrix}\r\nX(t)\\\\\r\nY(t)\r\n\\end{matrix}\r\n\\right]=\\exp\\left(\\left[\r\n\\begin{matrix}\r\nF & -GR^{-1}G^\\intercal \\\\\r\n-Q & -F^\\intercal\r\n\\end{matrix}\r\n\\right](t_1-t)\\right)\\left[\r\n\\begin{matrix}\r\nX(t_1)\\\\\r\nY(t_1)\r\n\\end{matrix}\r\n\\right].\r\n\\end{aligned}"}),"Setting,",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\n\\left[ \r\n\\begin{matrix}\r\n\\Phi_{11}(t) && \\Phi_{12}(t)\\\\\r\n\\Phi_{21}(t) && \\Phi_{22}(t)\r\n\\end{matrix}\r\n\\right]=\r\n\\exp\\left(\\left[\r\n\\begin{matrix}\r\nF & -GR^{-1}G^\\intercal \\\\\r\n-Q & -F^\\intercal\r\n\\end{matrix}\r\n\\right](t_1-t)\\right)\r\n\\end{aligned}"}),"then, the Riccati closed-form solution is",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\nP(t)=\\left[\\Phi_{21}(t)X(t_1)+\\Phi_{22}(t)Y(t_1)\\right]\\left[\\Phi_{11}(t)X(t_1)+\\Phi_{12}(t)Y(t_1)\\right]^{-1}.\r\n\\end{aligned}"}),r.a.createElement("h3",null,"Constant Coeff. and ",r.a.createElement(f,{math:"t_1\\rightarrow \\infty"})),"When ",r.a.createElement(f,{math:"t_1 \\rightarrow \\infty"})," with constant coefficients we obtain the so-called  ",r.a.createElement("i",null,"Algebraic Riccati Equation"),r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\nP_\\infty F+F^\\intercal P_\\infty-P_\\infty GR^{-1}G^\\intercal P_\\infty+Q=0.\r\n\\end{aligned}"}),r.a.createElement(_,{src:"/images/p_infinite.svg",width:"50%"}),"This is also known as the ",r.a.createElement("i",null,"Steady-state Solution")," of the Riccati Equation. It is implicitly assumed that the dynamic system associated with the Riccati equation is controllable and observable. The controllability assumption guaranteeing that the steady-state solution exists and the observability assumption assures that this solution is positive definite.",r.a.createElement("p",null),"There are plenty of different approaches in the literature to solve the Algebraic version of Riccati Equation . Here, we focus on only one method that consists in construct the augmented matrix",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r M=\\left[\r \\begin{matrix}\r F & -GR^{-1}G^\\intercal \\\\\r -Q & -F^\\intercal \r \\end{matrix}\r \\right].\r\n\\end{aligned}"}),"This ",r.a.createElement(f,{math:"M"})," matrix has the property that there is no pure imaginary eigenvalue and if ",r.a.createElement(f,{math:"\\lambda"})," is an eigenvalue  of ",r.a.createElement(f,{math:"M"}),"  so is ",r.a.createElement(f,{math:"-\\lambda"}),".  We then construct a matrix ",r.a.createElement(f,{math:"T"}),r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\nT=\\left[\r\n\\begin{matrix}\r\nT_{11} & T_{12} \\\\\r\nT_{21} & T_{22} \r\n\\end{matrix}\r\n\\right]\r\n\\end{aligned}"}),"such that",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r T^{-1}MT=\\left[\r \\begin{matrix}\r -\\Lambda & 0 \\\\\r 0 & \\Lambda \r \\end{matrix}\r \\right].\r\n\\end{aligned}"}),"Thus, the solution is simply given by",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r P_\\infty=T_{21}T_{11}^{-1}.\r\n\\end{aligned}"}),r.a.createElement("div",{className:"proof"},r.a.createElement("b",null,"Proof:")," ",r.a.createElement("br",null),"To check this solution, first notice that",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r MT=T\\left[\r \\begin{matrix}\r -\\Lambda & 0 \\\\\r 0 & \\Lambda \r \\end{matrix}\r \\right].\r\n\\end{aligned}"}),"This results in",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r FT_{11}-GR^{-1}G^\\intercal T_{21}&=-T_{11}\\Lambda,\\\\\r -QT_{11}-F^\\intercal T_{21}&=-T_{21}\\Lambda.\r\n\\end{aligned}"}),"Multiplying by ",r.a.createElement(f,{math:"T_{11}^{-1}"})," on the right side of both equations and by ",r.a.createElement(f,{math:"T_{21}T_{11}^{-1}"})," only in the first, we have",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r T_{21}T_{11}^{-1}F-T_{21}T_{11}^{-1}GR^{-1}G^\\intercal T_{21}T_{11}^{-1}=-T_{21}\\Lambda T_{11}^{-1}\r\n\\end{aligned}"}),"and",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r -Q-F^\\intercal T_{21}T_{11}^{-1}=-T_{21}\\Lambda T_{11}^{-1}.\r\n\\end{aligned}"}),"Therefore,",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r (T_{21}T_{11}^{-1})F+F^{\\intercal}(T_{21}T_{11}^{-1})-(T_{21}T_{11}^{-1})GR^{-1}G^\\intercal (T_{21}T_{11}^{-1})+Q=0.\\quad\\blacksquare\r\n\\end{aligned}"})),r.a.createElement("h3",null,r.a.createElement(f,{math:"P(t)"})," based on ",r.a.createElement(f,{math:"P_\\infty"})),"As discussed in ",r.a.createElement("b",null,r.a.createElement("a",{href:"#Anderson1971"},"[Anderson1971][pg. 361]")),", if the steady-state solution is available in advance, we can establish a closed-form solution for the differential Riccati Equation for the entire horizon. In other words, we seek the expression ",r.a.createElement(f,{math:"P(t)"})," for",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r -\\dot{P}=PF+F^\\intercal P-PGR^{-1}G^\\intercal P +Q,\r\n\\end{aligned}"}),"given ",r.a.createElement(f,{math:"P_\\infty"})," such that",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r P_\\infty F+F^\\intercal P_\\infty-P_\\infty GR^{-1}G^\\intercal P_\\infty +Q=0.\r\n\\end{aligned}"}),"For this purpose, consider",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r P(t)=P_\\infty+Z^{-1}(t),\\quad  t\\le 0\r\n\\end{aligned}"}),"where ",r.a.createElement(f,{math:"Z(t)"})," is the solution of",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\n\\dot{Z}(t)=[A-GR^{-1}G^\\intercal P_\\infty]Z(t)+Z(t)[A-GR^{-1}G^\\intercal P_\\infty]^\\intercal-GR^{-1}G^\\intercal\r\n\\end{aligned}"}),"which is a ",r.a.createElement("i",null,"Differential Lyapunov Equation"),". The solution for ",r.a.createElement(f,{math:"Z(t)"})," is",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r Z(t)=\\bar{Z}+e^{-\\tilde{A}t}[Z(0)-\\bar{Z}]e^{-\\tilde{A}^\\intercal t}\r\n\\end{aligned}"}),"where",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r \\tilde{A}&=A-GR^{-1}G^\\intercal P_\\infty\\\\\r 0&=\\tilde{A}\\bar{Z}+\\bar{Z}\\tilde{A}-GR^{-1}G^\\intercal\\\\\r Z(0)&=[P(0)-P_\\infty]^{-1}\r\n\\end{aligned}"}),"Thus, we can write the close-form solution for the Differential Riccati Equation as",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r P(t)=P_\\infty+[\\bar{Z}+e^{-\\tilde{A}t}[Z(0)-\\bar{Z}]e^{-\\tilde{A}^\\intercal t}]^{-1},\\quad t\\le 0\r\n\\end{aligned}"}),r.a.createElement("h2",null,"Analytical Solution of the Differential Lyapunov Equation"),"Consider the differential Lyapunov equation of the form",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\n\\dot{X}(t)=A^\\intercal X(t)+X(t)A+Q,\\quad X(0)=X_0.\r\n\\end{aligned}"}),r.a.createElement("div",{className:"lemma"},r.a.createElement("b",null,"Lemma:"),r.a.createElement("br",null),"The analytical closed-form solution for ",r.a.createElement("i",null,"Differential Lyapunov Equation")," is given by",r.a.createElement(p.BlockMath,{math:"\t\\begin{aligned}\r X(t)=\\bar{X}+e^{At}(X(0)-\\bar{X})e^{A^\\intercal t}.\r\n\\end{aligned}"}),"where ",r.a.createElement(f,{math:"\\bar{X}"})," is solution of the ",r.a.createElement("i",null,"Algebraic Lyapunov Equation"),r.a.createElement(p.BlockMath,{math:"\t\\begin{aligned}\r A\\bar{X}+\\bar{X}A^\\intercal -Q=0.\r\n\\end{aligned}"})),r.a.createElement("div",{className:"proof"},r.a.createElement("b",null,"Proof:"),r.a.createElement("br",null),"First, one can proof that if A is Hurwitz then the algebraic equation ",r.a.createElement("eqref",{eqref:"{eq-algebraic_lyapunov_negative}"})," has unique solution. Thus, we can rewrite ",r.a.createElement("eqref",{eqref:"{lyapunov_diff}"})," as",r.a.createElement(p.BlockMath,{math:"\t\\begin{aligned}\r \\frac{d}{dt}({X(t)-\\bar{X}})=A(X(t)-\\bar{X})+(X(t)-\\bar{X})A^\\intercal\r\n\\end{aligned}"}),"therefore,",r.a.createElement(p.BlockMath,{math:"\t\\begin{aligned}\r X(t)=\\bar{X}+e^{At}(X(0)-\\bar{X})e^{A^\\intercal t}.\\quad \\blacksquare\r\n\\end{aligned}"})),r.a.createElement("div",{className:"remark"},r.a.createElement("b",null,"Remark: "),"The solution of the ",r.a.createElement("i",null,"Algebraic Lyapunov Equation")," can be obtained employing the Kronecker Product",r.a.createElement(p.BlockMath,{math:"\t\\begin{aligned}\r vec(\\bar{X})=\\left[A\\otimes A\\right]^{-1}vec(Q).\r\n\\end{aligned}"})),r.a.createElement("h3",null,"References:"),r.a.createElement("p",null,r.a.createElement("b",null,r.a.createElement("a",{href:"#",name:"Anderson1971"}),"[Anderson1971]")," B. D. O. Anderson and J. B. Moore, Linear optimal control. 1971.")),r.a.createElement("p",null),r.a.createElement(k.a.DiscussionEmbed,{shortname:"marofe-github-io",config:a}))},T=function(e){var a={url:"https://marofe.github.io/?p="+e.note.link,identifier:"note-"+e.note.link,title:e.title};return r.a.createElement("article",null,r.a.createElement(d.a,null,r.a.createElement("title",null,e.note.title," | Marofe"),r.a.createElement("meta",{name:"description",content:e.note.desc})),r.a.createElement("h1",null,e.title),r.a.createElement("p",null,e.desc),r.a.createElement("p",{align:"right"},"Last Update:  1 March, 2020."),r.a.createElement("div",null,r.a.createElement("p",null,"Particle Filter perform ",r.a.createElement("i",null,"Sequential Monte Carlo"),' (SMC) Estimation based on point mass "particles" representation of probabilities densities. The basic SMC ideas in the form of ',r.a.createElement("i",null,"Sequential Importance Sampling")," (SIS) had been introduced in statistics back in the 1950s. Although, the major contribution to the development of SMC method was the inclusion of ",r.a.createElement("i",null,"resampling step"),", which coupled with the rise of faster and cheap computers made the particle filters quite useful in practical problems."),r.a.createElement("p",null,"The following content is based on the book ",r.a.createElement("a",{href:"#ristic"},"ristic2003beyond"),"."),r.a.createElement("h2",null,"Monte Carlo Integration"),"Suppose we want to evaluate a multidimensional integral in the form",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r I=\\int g(x)dx,\r\n\\end{aligned}"}),"where ",r.a.createElement(f,{math:"g: \\mathbb{R}^n \\rightarrow \\mathbb{R}^m"})," is some complicated function that it is not possible to integrate analytically. Now, if we can factorize ",r.a.createElement(f,{math:"g(x)=f(x)\\pi(x)"})," in such a way that ",r.a.createElement(f,{math:"\\pi: \\mathbb{R}^n\\rightarrow \\mathbb{R}"})," is interpreted as a probability density satisfying",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r I=\\int f(x)\\pi(x)dx,\\quad \\pi(x)\\ge 0,\\quad \\int \\pi(x)dx = 1\r\n\\end{aligned}"}),"and assuming that it is possible to draw ",r.a.createElement(f,{math:"N>>1"})," samples ",r.a.createElement(f,{math:"\\{x^i\\}_{i=1}^N"})," distributed according to ",r.a.createElement(f,{math:"\\pi(x)"}),", thus,  the SMC provides an estimate of ",r.a.createElement(f,{math:"I"})," given by",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r \\hat{I}_N = \\sum_{i=1}^{N}\\frac{1}{N}f(x^i).\r\n\\end{aligned}"}),"In this case, if ",r.a.createElement(f,{math:"\\{x^i\\}"})," are independent samples then we can show that ",r.a.createElement(f,{math:"\\hat{I}_N"})," is an ",r.a.createElement("i",null,"unbiased")," estimate of ",r.a.createElement(f,{math:"I"}),r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r \\mathbb{E}\\{I\\}=\\mathbb{E}\\{\\hat{I}_N\\},\r\n\\end{aligned}"}),"and according to the ",r.a.createElement("i",null,"law of large numbers"),", ",r.a.createElement(f,{math:"\\hat{I}_N"})," will almost surely converge to ",r.a.createElement(f,{math:"I"})," as ",r.a.createElement(f,{math:"N\\rightarrow \\infty"}),". The error of this MC estimator is of order ",r.a.createElement(f,{math:"\\mathcal{O}(N^{-1/2})"}),", meaning that the rate of convergence is independent of the dimension ",r.a.createElement(f,{math:"n"}),". This useful and important property of MC integration is due to the choice of samples ",r.a.createElement(f,{math:"x^i"})," according to ",r.a.createElement(f,{math:"\\pi(x)"}),", as they automatically come from regions of the state space that are important for the integration.",r.a.createElement("p",null),"In the Bayesian Estimation context, density ",r.a.createElement(f,{math:"\\pi(x)"})," is usually the ",r.a.createElement("i",null,"posterior")," density. Unfortunately, in almost all cases, it is not possible to sample effectively from the posterior distribution. To overcome this problem, a possible solution is to apply the so-called ",r.a.createElement("i",null,"Importance Sampling Method"),".",r.a.createElement("h3",null,"Importante Sampling Method"),"Suppose we can generate only samples from a specific density ",r.a.createElement(f,{math:"q(x)"}),", which is similar to ",r.a.createElement(f,{math:"\\pi(x)"}),". Then a correct weighting of the samples might still make the MC estimation effective. The pdf ",r.a.createElement(f,{math:"q(x)"})," is referred to as the ",r.a.createElement("i",null,"importance")," or ",r.a.createElement("i",null,"proposal"),' density. Its "similarity" with ',r.a.createElement(f,{math:"\\pi(x)"})," can be expressed by the following condition",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\n\\pi(x)>0 \\Rightarrow q(x)>0,\\quad \\forall x \\in \\mathbb{R}^n,\r\n\\end{aligned}"}),"which means that ",r.a.createElement(f,{math:"\\pi(x)"})," and ",r.a.createElement(f,{math:"q(x)"})," have the same support. If this condition is valid, then",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r I=\\int f(x)\\pi(x)dx = \\int f(x)\\frac{\\pi(x)}{q(x)}q(x)dx,\r\n\\end{aligned}"}),"provided that ",r.a.createElement(f,{math:"\\frac{\\pi(x)}{q(x)}"})," is ",r.a.createElement("i",null,"upper bounded"),". A MC estimate of ",r.a.createElement(f,{math:"I"})," is computed by generation ",r.a.createElement(f,{math:"N>>1"})," independents samples ",r.a.createElement(f,{math:"\\{x^i\\}"})," distributed according to ",r.a.createElement(f,{math:"q(x)"})," and forming the weighted sum",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r \\hat{I}_N=\\frac{1}{N}\\sum_{i=1}^N f(x^i)\\tilde{w}(x^i),\r\n\\end{aligned}"}),"where",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r \\tilde{w}(x^i)=\\frac{\\pi(x^i)}{q(x^i)},\r\n\\end{aligned}"}),"are the importance weights. If the normalization factor for the desired ",r.a.createElement(f,{math:"\\pi(x)"})," is unknown then we also need to perform normalization of the importance weights",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r \\hat{I}_N=\\frac{\\frac{1}{N}\\sum_{i=1}^N f(x^i)\\tilde{w}(x^i)}{\\frac{1}{N}\\sum_{i=1}^N \\tilde{w}(x^i)}=\\sum_{i=1}^N f(x^i)w(x^i),\r\n\\end{aligned}"}),"where",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r w(x^i)=\\frac{\\tilde{w}(x^i)}{\\sum_{j=1}^N\\tilde{w}(x^j)}.\r\n\\end{aligned}"}),r.a.createElement("h3",null,"Sequential Importance Sampling (SIS)"),"Importance Sampling is a general MC integration method. In another hand, the ",r.a.createElement("i",null,"Sequential Importance Sampling")," algorithm is a MC method that forms the basis for most sequential MC filters developed over the past decades.",r.a.createElement("p",null),"This sequential MC approach is known variously as ",r.a.createElement("i",null,"bootstrap filtering, the condensation algorithm, particle filters, interacting particles approximations and survival of the fittest"),". It is a technique for implementing recursive Bayesian Filters by MC simulations. The key idea is to represent the required posterior density function by a set of random samples with associated weights and compute estimates based on these samples and weights. As the number of samples becomes larger, the SIS filter approaches the optimal Bayesian Estimator.",r.a.createElement("p",null),"The joint posterior density at time ",r.a.createElement(f,{math:"k"})," can be approximated as follows",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\np(X_k|Z_k)\\approx \\sum_{i=1}^N w_k^i\\delta(X_k-X_k^i),\r\n\\end{aligned}"}),"where ",r.a.createElement(f,{math:"X_k=\\{x_0,x_1,\\ldots,x_k\\}"})," and ",r.a.createElement(f,{math:"Z_k=\\{z_0,z_1,\\ldots,z_k\\}"})," are the state path and measurement history, respectively. If the samples ",r.a.createElement(f,{math:"X_k^i"})," were drawn from an importance density ",r.a.createElement(f,{math:"q(X_k|Z_k)"})," then",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r w_k^i \\propto \\frac{p(X_k^i|Z_k)}{q(X_k^i|Z_k)}.\r\n\\end{aligned}"}),"Considering that the importance density is chosen to factorize such that",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r q(X_k|Z_k)=q(x_k|X_{k-1},z_k)q(X_{k-1}|Z_{k-1}),\r\n\\end{aligned}"}),"then we can obtain samples ",r.a.createElement(f,{math:"X_k^i \\sim q(X_k|Z_k)"})," by augmenting each of the existing samples ",r.a.createElement(f,{math:"X_{k-1}^i\\sim q(X_{k-1}|Z_{k-1})"})," with the new state ",r.a.createElement(f,{math:"x_k^i \\sim q(x_k|X_{k-1},z_k)"}),".",r.a.createElement("p",null),"To derive the weight update equation, the pdf ",r.a.createElement(f,{math:"p(X_k|Z_k)"})," is first factorized as",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r p(X_k|Z_k)&=p(X_k|z_k,Z_{k-1})\\\\\r &=\\frac{p(z_k|X_k,Z_{k-1})p(X_k|Z_{k-1})}{p(z_k|Z_{k-1})}\\\\\r &=\\frac{p(z_k|x_k,X_{k-1},Z_{k-1})p(x_k|X_{k-1},Z_{k-1})p(X_{k-1}|Z_{k-1})}{p(z_k|Z_{k-1})}\\\\\r &=\\frac{p(z_k|x_k,X_{k-1},Z_{k-1})p(x_k|x_{k-1},X_{k-2},Z_{k-1})p(X_{k-1}|Z_{k-1})}{p(z_k|Z_{k-1})}\\\\\r &=p(z_k|x_k)p(x_k|x_{k-1})\\frac{p(X_{k-1}|Z_{k-1})}{p(z_k|Z_{k-1})}.\r\n\\end{aligned}"}),"Thus,",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r p(X_k|Z_k)\\propto p(z_k|x_k)p(x_k|x_{k-1})P(X_{k-1}|Z_{k-1}).\r\n\\end{aligned}"}),"Substituting in ",r.a.createElement("a",{href:"#"},"eq:update_weight"),", we have",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r w_k^i \\propto \\frac{p(z_k|x_k^i)p(x_k^i|x_{k-1}^i)}{q(x_k^i|X_{k-1}^i,Z_k)}\\frac{p(X_{k-1}^i|Z_{k-1})}{q(X_{k-1}^i|Z_{k-1})},\r\n\\end{aligned}"}),"therefore, we conclude that",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r w_k^i\\propto w_{k-1}^i\\frac{p(z_k|x_k^i)p(x_k^i|x_{k-1}^i)}{q(x_k^i|X_{k-1}^i,Z_k)}.\r\n\\end{aligned}"}),"Now, if ",r.a.createElement(f,{math:"q(x_k|X_{k-1},Z_{k})=q(x_k|x_{k-1},z_k)"})," then",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\nw_k^i\\propto w_{k-1}^i\\frac{p(z_k|x_k^i)p(x_k^i|x_{k-1}^i)}{q(x_k^i|x_{k-1}^i,z_k)}.\r\n\\end{aligned}"}),"In this case, the posterior filtered density ",r.a.createElement(f,{math:"p(x_k|Z_k)"})," can be approximated as",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\np(x_k|Z_k)\\approx \\sum_{i=1}^n w_k^i\\delta(x_k-x_k^i).\r\n\\end{aligned}"}),"The Figure ",r.a.createElement("a",{href:"#"},"fig:pdf")," illustrate this approximation for a simple problem.",r.a.createElement(_,{src:"/images/pdf.svg",width:"50%"}),"Filtering via SIS thus consists of recursive propagation of importance weights ",r.a.createElement(f,{math:"w_k^i"})," and support points ",r.a.createElement(f,{math:"x_k^i"})," as each measurement is received sequentially. This simple and general algorithm forms the basis of most particle filters. However, the choice of the importance density ",r.a.createElement(f,{math:"q(x)"})," plays a crucial role in the design of this type of filter.",r.a.createElement("h3",null,"The Optimal Importance Density"),"The choice of importance density ",r.a.createElement(f,{math:"q(x_k|x_{k-1},z_k)"})," is one of the most critical issues in the design of a particle filter. The optimal importance density function that minimizes the variance of importance weights, conditioned upon ",r.a.createElement(f,{math:"x_{k-1}"})," and ",r.a.createElement(f,{math:"z_k"})," has been shown to be",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r q(x_k|x_{k-1},z_k)=p(x_k|x_{k-1},z_k).\r\n\\end{aligned}"}),"Substitution of ",r.a.createElement("a",{href:"#"},"eq:opt_q")," into ",r.a.createElement("a",{href:"#"},"eq:update2_weight")," yields",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\nw_k^i&\\propto w_{k-1}^i\\frac{p(z_k|x_k)p(x_k|x_{k-1}^i)}{p(x_k|x_{k-1}^i,z_k)}\\\\\r\n&\\propto w_{k-1}^i\\frac{p(z_k|x_k)p(x_k|x_{k-1}^i)p(z_k|x_{k-1}^i)}{p(z_k|x_k,x_{k-1}^i)p(x_k|x_{k-1}^i)}\\\\\r &\\propto w_{k-1}^ip(z_k|x_{k-1}^i),\r\n\\end{aligned}"}),"which states that importance weights at time ",r.a.createElement(f,{math:"k"})," can be computed (and resampling) before the particles even be propagated to time ",r.a.createElement(f,{math:"k"}),". In order to use the optimal importance function, one has to be able to (i) sample from ",r.a.createElement(f,{math:"p(x_k|x_{k-1}^i,z_k)"})," and (ii) evaluate",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r p(z_k|x_{k-1}^i)&=\\int p(z_k,x_k|x_{k-1}^i)dx_k\\\\\r &=\\int p(z_k|x_k)p(x_k|x_{k-1}^i)dx_k\r\n\\end{aligned}"}),"up to a normalizing constant. In the general case either these two may not be straightforward. However, there are some special cases where the use of optimal importance density is possible.",r.a.createElement("p",null),"The first case is when ",r.a.createElement(f,{math:"x_k"})," is a member of a finite set (e.g. jump-Markov linear systems). The second case is a class of models for which ",r.a.createElement(f,{math:"p(x_k|x_{k-1}^i,z_k)"})," is Gaussian.",r.a.createElement("h3",null,"Gaussian Optimal Importance Density"),"Consider the case where the state dynamics is nonlinear but the measurement equation is linear and all the random elements in the model are additive Gaussian",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\nx_k&=f_{k-1}(x_{k-1})+\\nu_{k-1}\\\\\r\nz_k&=H_kx_k+\\varepsilon_k\\\\\r\n\\nu_k\\sim &\\mathcal{N}(0,Q_k),\\quad \\varepsilon_k \\sim \\mathcal{N}(0,R_k)\r\n\\end{aligned}"}),"From the Bayes formula it follows that",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r p(x_k|x_{k-1},z_k)\\propto p(z_k|x_k)p(x_k|x_{k-1})\r\n\\end{aligned}"}),"as the measurement is linear and the random elements are Gaussian, ",r.a.createElement(f,{math:"p(x_k|x_{k-1},z_k)"})," will be the product of Gaussian distributions and therefore will result in another Gaussian. Besides, we can write",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r\np(x_k|x_{k-1},z_k)p(z_k|x_{k-1})= p(z_k|x_k)p(x_k|x_{k-1})\r\n\\end{aligned}"}),"Taking the logarithm both sides yield",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r p(x_k|x_{k-1},z_k)&\\sim \\mathcal{N}(a_k,\\Sigma_k),\\\\\r p(z_k|x_{k-1})&\\sim \\mathcal{N}(b_k,S_k),\r\n\\end{aligned}"}),"with",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r a_k&=f_{k-1}(x_{k-1})+\\Sigma_kH_k^\\intercal R_k^{-1}(z_k-b_k),\\\\\r \\Sigma_k &= Q_{k-1}-Q_{k-1}H_k^\\intercal S_k^{-1}H_kQ_{k-1},\\\\\r S_k &= H_kQ_{k-1}H_k^\\intercal + R_k,\\\\\r b_k&=H_kf_{k-1}(x_{k-1}).\r\n\\end{aligned}"}),r.a.createElement("h3",null,"Degeneracy Problem and Resampling"),"Ideally, the importance density function should be the posterior density itself ",r.a.createElement(f,{math:"p(x_k|Z_k)"}),". However, as this cannot be achieved, the variance of the importance weights might increase over time. This leads to the ",r.a.createElement("i",null,"degeneracy phenomenon"),".",r.a.createElement("p",null),"In practical terms, this means that after a certain number of steps, all but one particle will have negligible normalized weight. The degeneracy is impossible to avoid in the SIS framework and, hence, it was a major stumbling block in the development of sequential MC methods. Because a large computational effort is devoted to updating particles whose contribution to the approximation of ",r.a.createElement(f,{math:"p(x_k|Z_k)"})," is almost zero.",r.a.createElement("p",null),"One measure of degeneracy of a SIS algorithm follows",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r N_{eff}=\\frac{1}{\\sum_{i=1}^N(w_k^i)^2}.\r\n\\end{aligned}"}),"It is straightforward to verify that ",r.a.createElement(f,{math:"1\\le N_{eff}\\le N"})," with the following extreme cases: (i) if the weights are uniform (i.e. ",r.a.createElement(f,{math:"w_k^i=\\frac{1}{N}"}),") then ",r.a.createElement(f,{math:"N_{eff}=N"}),"; and (ii) if ",r.a.createElement(f,{math:"\\exists j\\in \\{1,\\ldots,N\\}"})," such that ",r.a.createElement(f,{math:"w_k^j=1"})," and ",r.a.createElement(f,{math:"w_k^i=0"})," for all ",r.a.createElement(f,{math:"i\\neq j"}),", then ",r.a.createElement(f,{math:"N_{eff}=1"}),". Therefore, small ",r.a.createElement(f,{math:"N_{eff}"})," indicates a severe degeneracy and vice versa.",r.a.createElement("p",null),"To cope with this problem, we need to perform a resampling step whenever a significant degeneracy is observed (i.e. when ",r.a.createElement(f,{math:"N_{eff}"})," fall below some threshold ",r.a.createElement(f,{math:"N_{thr}"}),"). Resampling eliminates samples with low importance and multiplies ones with high importance.",r.a.createElement("p",null),"It involves a mapping of random measures ",r.a.createElement(f,{math:"\\{x_k^i,w_k^i\\}_{i=1}^N"})," into new ones ",r.a.createElement(f,{math:"\\{\\tilde{x}_k^i,\\frac{1}{N}\\}_{i=1}^N"})," with uniform weights. The new set of samples ",r.a.createElement(f,{math:"\\{\\tilde{x}_k^i\\}_{i=1}^N"})," is generated by resampling (with replacement) ",r.a.createElement(f,{math:"N"})," times from the approximate discrete representation of ",r.a.createElement(f,{math:"p(x_k|Z_k)"}),", so that ",r.a.createElement(f,{math:"P\\{\\tilde{x}_k^i=x_k^j\\}=w_k^j"}),". The resulting samples compose an i.i.d set and hence the new weights are uniform.",r.a.createElement("p",null),"One way to implement the resampling step is by the ",r.a.createElement("i",null,"Cumulative Sum of Weight Algorithm")," (CSW). This implementation consist of generating ",r.a.createElement(f,{math:"N"})," i.i.d variables from the uniform distribution ",r.a.createElement(f,{math:"\\mathcal{U}[0,1]"}),", sorting them in ascending order and comparing them with the cumulative sum of normalized weights. The Figure ",r.a.createElement("a",{href:"#"},"fig:csw")," illustrate this procedure.",r.a.createElement(_,{src:"/images/csw.svg",width:"50%"}),r.a.createElement("h2",null,"The Bootstrap Filter (SIR)"),"Proposed in ",r.a.createElement("a",{href:"#gordon"},"gordon1993novel"),". The ",r.a.createElement("i",null,"Sequential Importance Resampling")," (SIR) filter is derived from the SIS algorithm by choosing the importance density to be the ",r.a.createElement("i",null,"transitional prior")," and performing resampling every time step.",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r q(x_k|x_{k-1},z_k)=p(x_k|x_{k-1}).\r\n\\end{aligned}"}),"A sample ",r.a.createElement(f,{math:"x_k^i\\sim p(x_k|x_{k-1}^i)"})," can be generated first generating a process noise sample ",r.a.createElement(f,{math:"\\nu_{k-1}^i\\sim p(\\nu_k)"})," and setting ",r.a.createElement(f,{math:"x_k^i=f(x_{k-1}^i,\\nu_{k-1}^i)"}),". For this particular choice of importance density, the weight update is",r.a.createElement(p.BlockMath,{math:"\t\\begin{aligned}\r w_k^i\\propto w_{k-1}^ip(z_k|x_k).\r\n\\end{aligned}"}),"However, as the resampling step is performed every iteration, we have ",r.a.createElement(f,{math:"w_{k-1}^i=\\frac{1}{N}"})," for all ",r.a.createElement(f,{math:"i=1,\\ldots,N"}),". Thus, the weight update simplifies to",r.a.createElement(p.BlockMath,{math:"\t\\begin{aligned}\r w_k^i \\propto p(z_k|x_k).\r\n\\end{aligned}"}),r.a.createElement("h3",null,"Cons"),"As the importance sampling is independent of measurement ",r.a.createElement(f,{math:"z_k"}),", the state space is explored without any knowledge of the observations. Therefore, this filter is sensitive to outliers. Furthermore, as resampling is applied every iteration, this can result in rapid ",r.a.createElement("i",null,"loss of diversity")," in particles.",r.a.createElement("h3",null,"Pros"),"The SIR method has the advantage that the importance weights are easily evaluated and the importance density can be easily sampled.",r.a.createElement("h2",null,"Local Linearization Particle Filters (LLPF)"),"The optimal importance density can be approximated by incorporating the most current measurement ",r.a.createElement(f,{math:"z_k"})," via a bank of extended or unscented Kalman Filters. The idea is to use for each particle a separate EKF or UKF to generate and propagate a Gaussian importance distribution; that is,",r.a.createElement(p.BlockMath,{math:"\\begin{aligned}\r q(x_k^i|x_{k-1}^i,z_k)=\\mathcal{N}(\\hat{x}_k^i,\\hat{P}_k^i),\r\n\\end{aligned}"}),"where ",r.a.createElement(f,{math:"\\hat{x}_k^i"})," and ",r.a.createElement(f,{math:"\\hat{P}_k^i"})," are estimates of the mean and covariance computed by EKF or UKF at time ",r.a.createElement(f,{math:"k"})," using measurement ",r.a.createElement(f,{math:"z_k"}),". We refer to the corresponding particle filter as the ",r.a.createElement("i",null,"Local Linearization Particle Filter")," (LLPF).",r.a.createElement("p",null),"The local linearization method for approximation of the importance density propagates the particles towards the likelihood function and consequently, the LLPF performs better than SIR filter. The additional computational cost of using such an importance density is often more than offset by a reduction in the number of samples required to achieve a certain level of performance.",r.a.createElement("div",{className:"remark"},r.a.createElement("b",null,"Remark: "),"Since Particle Filters are very expensive in terms of computational requirements, one should use them only in cases in which the conventional Kalman Filter does not produce satisfactory results."),r.a.createElement("h3",null,"References:"),r.a.createElement("p",null,r.a.createElement("a",{name:"gordon"}),"GORDON, N. J.; SALMOND, D. J.; SMITH, A. F. Novel approach to nonlinear/nongaussian bayesian state estimation. In: IET. IEE proceedings F (radar and signal processing). [S.l.], 1993. v. 140, n. 2, p. 107\u2013113"),r.a.createElement("p",null,r.a.createElement("a",{name:"ristic"}),"RISTIC, B.; ARULAMPALAM, S.; GORDON, N. Beyond the Kalman Filter: Particle Filters for Tracking Applications. [S.l.]: Artech House, 2003. ISBN 9781580538510.")),r.a.createElement(k.a.DiscussionEmbed,{shortname:"marofe-github-io",config:a}))},N=function(e){var a;switch(e.note.class){case"EkfLie":a=r.a.createElement(R,{note:e.note});break;case"RiccatiEq":a=r.a.createElement(I,{note:e.note});break;case"particleFilter":a=r.a.createElement(T,{note:e.note})}return r.a.createElement("div",{className:"divNote"},r.a.createElement("div",{className:"top"},r.a.createElement("h1",null,e.note.title),r.a.createElement("p",null,e.note.desc)),a)},z=function(e){function a(){var e,t;Object(w.a)(this,a);for(var n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return(t=Object(F.a)(this,(e=Object(M.a)(a)).call.apply(e,[this].concat(i)))).states={notes:[{id:0,title:"Extend Kalman Filter on Lie Groups",desc:"Here I provide the main equations for implementation of Extend Kalman Filter on Lie Groups.",link:"ekf-lie-groups",class:"EkfLie"},{id:1,title:"Analytical Solution of Riccati Equations",desc:"The Differential Riccati Equations are essential to solving many problems in optimal control and filtering. In this note, the analytical solution is discussed for both finite and infinite horizons.",link:"riccati-equation",class:"RiccatiEq"},{id:2,title:"Particle Filter and Monte Carlo Integration",desc:'Particle Filter perform Sequential Monte Carlo (SMC) Estimation based on point mass "particles" representation of probabilities densities. The basic SMC ideas in the form of Sequential Importance Sampling had been introduced in statistics back in the 1950s. In this note, an overview of this method is provided.',link:"particle-filter",class:"particleFilter"}]},t.routes=t.states.notes.map(function(e){return r.a.createElement(s.a,{path:"/notes/"+e.link,render:function(a){return r.a.createElement(N,{note:e})}})}),t}return Object(P.a)(a,e),Object(y.a)(a,[{key:"render",value:function(){var e=this;return r.a.createElement("div",{className:"divPage"},r.a.createElement(s.a,{path:"/notes",exact:!0,render:function(a){return r.a.createElement(q,{notes:e.states.notes})}}),this.routes)}}]),a}(n.Component),S=function(e){return r.a.createElement("header",{className:"fix"},e.children)},j=function(){return r.a.createElement("div",{className:"divnav"},r.a.createElement("nav",null,r.a.createElement("ul",null,r.a.createElement("li",null,r.a.createElement("a",{href:"/"},"Home")),r.a.createElement("li",null,r.a.createElement("a",{href:"/tutorials"},"Tutorials")),r.a.createElement("li",null,r.a.createElement("a",{href:"/notes"},"Notes")),r.a.createElement("li",null,r.a.createElement("a",{href:"/publications"},"Publications")),r.a.createElement("li",null,r.a.createElement("img",{className:"brazilFlag",src:"https://upload.wikimedia.org/wikipedia/commons/thumb/0/05/Flag_of_Brazil.svg/2000px-Flag_of_Brazil.svg.png",alt:"Brazil's flag"})))))},B=function(e){var a=(new Date).getFullYear();return r.a.createElement("div",{className:"bottom"},a," - \xa9 Copyright - All rights reserved.")};var C=function(){return r.a.createElement(l,null,r.a.createElement(S,null,r.a.createElement("div",{className:"divHeader"},r.a.createElement("h2",null,"Marcos R. Fernandes")),r.a.createElement(j,null)),r.a.createElement(m.a,{basename:""},r.a.createElement(s.a,{path:"/",exact:!0,component:h}),r.a.createElement(s.a,{path:"/publications",component:u}),r.a.createElement(s.a,{path:"/tutorials",component:A}),r.a.createElement(s.a,{path:"/notes",component:z})),r.a.createElement(B,null))};Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));o.a.render(r.a.createElement(C,null),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then(function(e){e.unregister()})}},[[32,1,2]]]);
//# sourceMappingURL=main.c6248e75.chunk.js.map